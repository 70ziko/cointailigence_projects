const { LowSync, JSONFileSync } = require('@commonify/lowdb')
const { v4: uuidv4 } = require('uuid')
const types = require('./types')

const {
    dbNotConnectedError,
    keyExistsError,
    keyDoesntExistError,
    incorrectFieldTypesError,
    fieldDoesntExistError
} = require('./errors')

class db {
    /**
     * @type {Low}
     */
    lowdb

    /**
     * @type {object}
     */
    fields

    types = types

    /**
     * Each field is readable with getField(key) and writable with setField(key, value)
     * @param {string} file - name of the <file>.json and <file>.def.js
     * @returns {db} 
     */
    constructor(file) {
        const containerName = __dirname.split('/')[2]
        try {
            const jsonPath = process.cwd() + `/data/db/${file}.json`
            const fieldsPath = process.cwd() + `/data/def/${file}.def.js`
            this.fields = require(fieldsPath)
            this.lowdb = new LowSync(new JSONFileSync(jsonPath))
            this.lowdb.read()
            this.lowdb.data ||= {}
            this._createGettersAndSetters()
            console.log(`Connected to ${containerName}.${file}`)
        } catch (error) {
            console.log(error)
            console.log(`Failed to connect to ${containerName}.${file}`)
        }
    }

    /**
     * Create new entry with key as key and json as data.
     * @param {string} key 
     * @param {object} json 
     * @returns {Promise<string>} id of the new entry, empty string if something went wrong
     * @throws {Error} if entry db not connected
     * @throws {Error} if entry already exists
     * @throws {Error} if incorrect field types
     */
    async create(key, json) {
        dbNotConnectedError(this.lowdb)
        keyExistsError(this.lowdb, key)
        incorrectFieldTypesError(this.fields, json)
        try {
            this.lowdb.data[key] = json
            await this.lowdb.write()
            return key
        } catch (error) {
            return ''
        }
    }

    /**
     * Check if given key exists
     * @param {string} key 
     * @returns {Promise<boolean>} true if key exists, false if not
     * @throws {Error} if db not connected
     */
    async exists(key) {
        dbNotConnectedError(this.lowdb)
        return this.lowdb.data.hasOwnProperty(key)
    }

    /**
     * Generate a unique key with uuidv4
     * @returns {string}
     */
    generateUniqueKey() {
        return uuidv4()
    }

    //TODO rename to getById
    /**
     * Get entry data by key
     * @param {string} key
     * @returns {Promise<object>}
     * @throws {Error} if entry doesn't exist
     * @throws {Error} if entry db not connected
     */
    async get(key) {
        dbNotConnectedError(this.lowdb)
        keyDoesntExistError(this.lowdb, key)
        try {
            return { ...this.lowdb.data[key], _id: key }
        } catch (error) {
            return {}
        }
    }

    /**
     * Get all data from the database as an array of objects
     * @returns {Promise<object[]>}
     */
    async getAll() {
        dbNotConnectedError(this.lowdb)
        try {
            return Object.keys(this.lowdb.data).map(key => ({ ...this.lowdb.data[key], _id: key }))
        } catch (error) {
            return []
        }
    }

    //TODO rename to getByQuery
    /**
     * Filter out entries that have the given field and value equal to the field value pair in fields object
     * @param {object} fields
     * @returns {Promise<object[]>}
     * @throws {Error} if db not connected
     * @throws {Error} if field doesn't exist
     * @example
     * // returns all entries with field 'name' equal to 'John'
     * db.getAllByFields({ name: 'John' })
     * // Can be used with multiple fields
     * db.getAllByFields({ name: 'John', age: 20 })
     */
    async getAllByFields(fields) {
        let fieldKeys
        dbNotConnectedError(this.lowdb)
        try {
            fieldKeys = Object.keys(fields)
            if (fieldKeys.length === 0) return this.getAll()
        } catch (error) {
            return []
        }

        for (const field of fieldKeys) fieldDoesntExistError(this.fields, field)

        try {
            const entries = await this.getAll()
            for (const field of fieldKeys) {
                entries.filter(entry => entry[field] == fields[field])
            }
            return entries
        } catch (error) {
            return []
        }
    }

    /**
     * number of entries in the database
     * @returns {Promise<number>} 
     * @throws {Error} if db not connected
     */
    async length() {
        dbNotConnectedError(this.lowdb)
        return Object.keys(this.lowdb.data).length
    }

    /**
     * Remove an entry from the database
     * @param {string} key 
     * @returns {Promise<boolean>} true if entry deleted, false if something went wrong
     * @throws {Error} if db not connected
     * @throws {Error} if entry doesn't exist
     */
    async remove(key) {
        dbNotConnectedError(this.lowdb)
        keyDoesntExistError(this.lowdb, key)
        try {
            delete this.lowdb.data[key]
            await this.lowdb.write()
            return true
        } catch (error) {
            return false
        }
    }

    /**
     * Update entry data by key
     * @param {string} key
     * @param {object} json
     * @returns {Promise<boolean>} true if entry updated, false if something went wrong
     * @throws {Error} if db not connected
     * @throws {Error} if entry doesn't exist
     * @throws {Error} if incorrect field types
     */
    async update(key, json) {
        dbNotConnectedError(this.lowdb)
        keyDoesntExistError(this.lowdb, key)
        incorrectFieldTypesError(this.fields, json)
        try {
            this.lowdb.data[key] = { ...this.lowdb.data[key], ...json }
            await this.lowdb.write()
            return true
        } catch (error) {
            return false
        }
    }

    /**
     * Private method to capitalize first letter of string
     * @param {string} string
     * @returns {string}
     * @private
     */
    static _capitalize(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    /**
     * Private method to create getters and setters for entry fields
     * @private
     * @returns {void}
     */
    _createGettersAndSetters() {
        let functions = {}
        Object.keys(this.fields).forEach(field => {
            const fieldType = this.fields[field]

            const getMethod = 'get' + db._capitalize(field)
            functions[getMethod] = async function (key) {
                //TODO add error handling
                return await this.lowdb.data[key][field]
            }

            const setMethod = 'set' + db._capitalize(field)
            functions[setMethod] = async function (key, value) {
                //TODO add error handling and type checking
                // Check if value is correct type
                if (fieldType.type === 'any' || typeof value === fieldType.type) {
                    //if value is null or undefined
                    if (value === null || value === undefined) {
                        if (fieldType.type.includes("?")) {
                            this.lowdb.data[key][field] = value
                            await this.lowdb.write()
                            return
                        }
                        throw new Error(`Field ${field} cannot be null or undefined`)
                    }
                    this.lowdb.data[key][field] = value
                    await this.lowdb.write()
                    return
                } else
                    throw new Error(`${field} must be ${fieldType.type}, is ${typeof value}`)
            }
        })
        Object.assign(this, functions)
    }
}

module.exports = db