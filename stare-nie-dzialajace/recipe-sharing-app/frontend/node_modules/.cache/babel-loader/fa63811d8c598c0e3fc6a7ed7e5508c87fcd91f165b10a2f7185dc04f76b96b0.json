{"ast":null,"code":"import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { fetchI18nBundle, getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport SliderBase from \"./SliderBase.js\";\n\n// Template\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n/**\n * @public\n */\nconst metadata = {\n  tag: \"ui5-range-slider\",\n  languageAware: true,\n  managedSlots: true,\n  properties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */{\n    /**\n     * Defines start point of a selection - position of a first handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    startValue: {\n      type: Float,\n      defaultValue: 0\n    },\n    /**\n     * Defines end point of a selection - position of a second handle on the slider.\n     * <br><br>\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    endValue: {\n      type: Float,\n      defaultValue: 100\n    }\n  }\n};\n\n/**\n * @class\n *\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range</li>\n * <li>max - The maximum value of the slider range</li>\n * <li>value - The current value of the slider</li>\n * <li>step - Determines the increments in which the slider will move</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle</li>\n * <li>showTickmarks - Displays a visual divider between the step values</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:<h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common usecase is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n  static get metadata() {\n    return metadata;\n  }\n  static get template() {\n    return RangeSliderTemplate;\n  }\n  constructor() {\n    super();\n    this._stateStorage.startValue = null;\n    this._stateStorage.endValue = null;\n    this.i18nBundle = getI18nBundle(\"@ui5/webcomponents\");\n  }\n  get tooltipStartValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.startValue.toFixed(stepPrecision);\n  }\n  get tooltipEndValue() {\n    const stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n    return this.endValue.toFixed(stepPrecision);\n  }\n\n  /**\n   * Check if the previously saved state is outdated. That would mean\n   * either it is the initial rendering or that a property has been changed\n   * programatically - because the previous state is always updated in\n   * the interaction handlers.\n   *\n   * Normalize current properties, update the previously stored state.\n   * Update the visual UI representation of the Slider.\n   *\n   */\n  onBeforeRendering() {\n    if (!this.isCurrentStateOutdated()) {\n      return;\n    }\n    this.notResized = true;\n    this.syncUIAndState(\"startValue\", \"endValue\");\n    this._updateHandlesAndRange(null);\n  }\n\n  /**\n   * Called when the user starts interacting with the slider\n   *\n   * @private\n   */\n  _onmousedown(event) {\n    // If step is 0 no interaction is available because there is no constant\n    // (equal for all user environments) quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n\n    // Calculate the new value from the press position of the event\n    const newValue = this.handleDownBase(event);\n\n    // Determine the rest of the needed details from the start of the interaction.\n    this._saveInteractionStartData(event, newValue);\n\n    // Do not yet update the RangeSlider if press is in range or over a handle.\n    if (this._inCurrentRange || this._handeIsPressed) {\n      this._handeIsPressed = false;\n      return;\n    }\n\n    // Update Slider UI and internal state\n    this._updateHandlesAndRange(newValue);\n    this.updateValue(this._valueAffected, newValue);\n    this.storePropertyState(this._valueAffected);\n  }\n\n  /**\n   * Determines and saves needed values from the start of the interaction:\n   *\n   * Is the value calculated is within the currently selected range;\n   * Initial pageX position of the start handle affected by the interaction;\n   * Initial pageX value of the pressed postion;\n   * Affected value property by the action;\n   *\n   * @private\n   */\n  _saveInteractionStartData(event, newValue) {\n    const progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n    // Save the state of the value properties on the start of the interaction\n    this._prevStartValue = this.startValue;\n    this._prevEndValue = this.endValue;\n\n    // Check if the new value is in the current select range of values\n    this._inCurrentRange = newValue > this._prevStartValue && newValue < this._prevEndValue;\n    // Save the initial press point coordinates (position)\n    this._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n    // Which element of the Range Slider is pressed and which value property to be modified on further interaction\n    this._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\n    // Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n    // We will use it as a reference to calculate a moving offset if the whole range selection is dragged.\n    this._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n  }\n\n  /**\n   * Called when the user moves the slider\n   *\n   * @private\n   */\n  _handleMove(event) {\n    event.preventDefault();\n\n    // If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n    if (this.disabled || this._effectiveStep === 0) {\n      return;\n    }\n\n    // Update UI and state when dragging a single Range Slider handle\n    if (!this._inCurrentRange) {\n      this._updateValueOnHandleDrag(event);\n      return;\n    }\n\n    // Updates UI and state when dragging of the whole selected range\n    this._updateValueOnRangeDrag(event);\n  }\n\n  /**\n   * Updates UI and state when dragging a single Range Slider handle\n   *\n   * @private\n   */\n  _updateValueOnHandleDrag(event) {\n    const newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n    this._updateHandlesAndRange(newValue);\n    this.updateValue(this._valueAffected, newValue);\n    this.storePropertyState(this._valueAffected);\n  }\n\n  /**\n   * Updates UI and state when dragging of the whole selected range\n   *\n   * @private\n   */\n  _updateValueOnRangeDrag(event) {\n    // Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n    const currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n    const newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n    // No matter the which value is set as the one to be modified (this._valueAffected) we want to modify both of them\n    this._valueAffected = null;\n\n    // Update the UI and the state acccording to the calculated new values\n    this.updateValue(\"startValue\", newValues[0]);\n    this.updateValue(\"endValue\", newValues[1]);\n    this._updateHandlesAndRange(null);\n    this.storePropertyState(\"startValue\", \"endValue\");\n  }\n  _handleUp() {\n    if (this.startValue !== this._prevStartValue || this.endValue !== this._prevEndValue) {\n      this.fireEvent(\"change\");\n    }\n    this._swapValues();\n    this.handleUpBase();\n    this._valueAffected = null;\n    this._prevStartValue = null;\n    this._prevEndValue = null;\n  }\n\n  /**\n   * Determines where the press occured and which values of the Range Slider\n   * handles should be updated on further interaction.\n   *\n   * If the press is not in the selected range or over one of the Range Slider handles\n   * determines which one from the value/endValue properties has to be updated\n   * after the user action (based on closest handle).\n   *\n   * Set flags if the press is over a handle or in the selected range,\n   * in such cases no values are changed on interaction start, but could be\n   * updated later when dragging.\n   *\n   * @private\n   */\n  _pressTargetAndAffectedValue(clientX, value) {\n    const startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n    const endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n    // Check if the press point is in the bounds of any of the Range Slider handles\n    const handleStartDomRect = startHandle.getBoundingClientRect();\n    const handleEndDomRect = endHandle.getBoundingClientRect();\n    const inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n    const inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n    // Remove the flag for value in current range if the press action is over one of the handles\n    if (inHandleEndDom || inHandleStartDom) {\n      this._inCurrentRange = false;\n      this._handeIsPressed = true;\n    }\n\n    // Return that handle that is closer to the press point\n    if (inHandleEndDom || value > this.endValue) {\n      this._valueAffected = \"endValue\";\n    }\n\n    // If one of the handle is pressed return that one\n    if (inHandleStartDom || value < this.startValue) {\n      this._valueAffected = \"startValue\";\n    }\n  }\n\n  /**\n   * Calculates startValue/endValue properties when the whole range is moved.\n   *\n   * Uses the change of the position of the start handle and adds the initially\n   * selected range to it, to determine the whole range offset.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n  _calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n    // Return the current values if there is no difference in the\n    // possitions of the initial press and the current pointer\n    if (this._initialPageXPosition === currentPageXPos) {\n      return [this.startValue, this.endValue];\n    }\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const selectedRange = this.endValue - this.startValue;\n\n    // Computes the new value based on the difference of the current cursor location from the start of the interaction\n    let startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n    // When the end handle reaches the max possible value prevent the start handle from moving\n    // And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n    startValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n    return [startValue, startValue + selectedRange];\n  }\n\n  /**\n   * Computes the new value based on the difference of the current cursor location from the\n   * start of the interaction.\n   *\n   * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n   * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n   *\n   * @private\n   */\n  _calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const step = this._effectiveStep;\n    const dom = this.getBoundingClientRect();\n    let startValue;\n    let startValuePageX;\n    let positionOffset;\n\n    /* Depending on the dragging direction:\n    - calculate the new position of the start handle from its old pageX value combined with the movement offset;\n    - calculate the start value based on its new pageX coordinates;\n    - 'stepify' the calculated value based on the specified step property; */\n    if (currentPageXPos > this._initialPageXPosition) {\n      // Difference between the new position of the pointer and when the press event initial occured\n      positionOffset = currentPageXPos - this._initialPageXPosition;\n      startValuePageX = initialStartHandlePageXPos + positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    } else {\n      positionOffset = this._initialPageXPosition - currentPageXPos;\n      startValuePageX = initialStartHandlePageXPos - positionOffset;\n      startValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n      startValue = this.constructor.getSteppedValue(startValue, step, min);\n    }\n    return startValue;\n  }\n  _updateHandlesAndRange(newValue) {\n    const max = this._effectiveMax;\n    const min = this._effectiveMin;\n    const prevStartValue = this.getStoredPropertyState(\"startValue\");\n    const prevEndValue = this.getStoredPropertyState(\"endValue\");\n\n    // The value according to which we update the UI can be either the startValue\n    // or the endValue property. It is determined in _getClosestHandle()\n    // depending on to which handle is closer the user interaction.\n    if (this._valueAffected === \"startValue\") {\n      // When the value changing is the start value:\n      this._selectedRange = (prevEndValue - newValue) / (max - min);\n      this._firstHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else if (this._valueAffected === \"endValue\") {\n      // Wen the value changing is the end value:\n      this._selectedRange = (newValue - prevStartValue) / (max - min);\n      this._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n    } else {\n      // When both values are changed - UI sync or moving the whole selected range:\n      this._selectedRange = (this.endValue - this.startValue) / (max - min);\n      this._firstHandlePositionFromStart = (this.startValue - min) / (max - min) * 100;\n      this._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n    }\n  }\n\n  /**\n   * Swaps start and end values and handles (thumbs), if one came accros the other\n   *\n   * @private\n   */\n  _swapValues() {\n    // If the start value is greater than the endValue swap them and their handles\n    if (this._valueAffected === \"startValue\" && this.startValue > this.endValue) {\n      const oldEndValue = this.endValue;\n      this.endValue = this.startValue;\n      this.startValue = oldEndValue;\n      return;\n    }\n\n    // If the endValue become less than the start value swap them and their handles\n    if (this._valueAffected === \"endValue\" && this.endValue < this.startValue) {\n      const oldStartValue = this.startValue;\n      this.startValue = this.endValue;\n      this.endValue = oldStartValue;\n    }\n  }\n  get styles() {\n    return {\n      progress: {\n        \"transform\": `scaleX(${this._selectedRange})`,\n        \"transform-origin\": `${this.directionStart} top`,\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      startHandle: {\n        [this.directionStart]: `${this._firstHandlePositionFromStart}%`\n      },\n      endHandle: {\n        [this.directionStart]: `${this._secondHandlePositionFromStart}%`\n      },\n      tickmarks: {\n        \"background\": `${this._tickmarks}`\n      },\n      label: {\n        \"width\": `${this._labelWidth}%`\n      },\n      labelContainer: {\n        \"width\": `100%`,\n        [this.directionStart]: `-${this._labelWidth / 2}%`\n      },\n      tooltip: {\n        \"visibility\": `${this._tooltipVisibility}`\n      }\n    };\n  }\n  static async onDefine() {\n    await fetchI18nBundle(\"@ui5/webcomponents\");\n  }\n}\nRangeSlider.define();\nexport default RangeSlider;","map":{"version":3,"names":["Float","fetchI18nBundle","getI18nBundle","SliderBase","RangeSliderTemplate","metadata","tag","languageAware","managedSlots","properties","startValue","type","defaultValue","endValue","RangeSlider","template","constructor","_stateStorage","i18nBundle","tooltipStartValue","stepPrecision","_getDecimalPrecisionOfNumber","_effectiveStep","toFixed","tooltipEndValue","onBeforeRendering","isCurrentStateOutdated","notResized","syncUIAndState","_updateHandlesAndRange","_onmousedown","event","disabled","newValue","handleDownBase","_saveInteractionStartData","_inCurrentRange","_handeIsPressed","updateValue","_valueAffected","storePropertyState","progressBarDom","shadowRoot","querySelector","getBoundingClientRect","_prevStartValue","_prevEndValue","_initialPageXPosition","getPageXValueFromEvent","_pressTargetAndAffectedValue","_initialStartHandlePageX","directionStart","left","right","_handleMove","preventDefault","_updateValueOnHandleDrag","_updateValueOnRangeDrag","getValueFromInteraction","_effectiveMin","_effectiveMax","currentPageXPos","newValues","_calculateRangeOffset","_handleUp","fireEvent","_swapValues","handleUpBase","clientX","value","startHandle","endHandle","handleStartDomRect","handleEndDomRect","inHandleStartDom","inHandleEndDom","initialStartHandlePageXPos","min","max","selectedRange","_calculateStartValueByOffset","clipValue","step","dom","startValuePageX","positionOffset","computedValueFromPageX","getSteppedValue","prevStartValue","getStoredPropertyState","prevEndValue","_selectedRange","_firstHandlePositionFromStart","_secondHandlePositionFromStart","oldEndValue","oldStartValue","styles","progress","tickmarks","_tickmarks","label","_labelWidth","labelContainer","tooltip","_tooltipVisibility","onDefine","define"],"sources":["/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/@ui5/webcomponents/dist/RangeSlider.js"],"sourcesContent":["import Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport { fetchI18nBundle, getI18nBundle } from \"@ui5/webcomponents-base/dist/i18nBundle.js\";\nimport SliderBase from \"./SliderBase.js\";\n\n// Template\nimport RangeSliderTemplate from \"./generated/templates/RangeSliderTemplate.lit.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\ttag: \"ui5-range-slider\",\n\tlanguageAware: true,\n\tmanagedSlots: true,\n\tproperties: /** @lends sap.ui.webcomponents.main.RangeSlider.prototype */  {\n\t\t/**\n\t\t * Defines start point of a selection - position of a first handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tstartValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines end point of a selection - position of a second handle on the slider.\n\t\t * <br><br>\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tendValue: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t},\n};\n\n/**\n * @class\n *\n * Represents a numerical interval and two handles (grips) to select a sub-range within it.\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n * The purpose of the component to enable visual selection of sub-ranges within a given interval.\n *\n * <h3>Structure</h3>\n * The most important properties of the Range Slider are:\n * <ul>\n * <li>min - The minimum value of the slider range</li>\n * <li>max - The maximum value of the slider range</li>\n * <li>value - The current value of the slider</li>\n * <li>step - Determines the increments in which the slider will move</li>\n * <li>showTooltip - Determines if a tooltip should be displayed above the handle</li>\n * <li>showTickmarks - Displays a visual divider between the step values</li>\n * <li>labelInterval - Labels some or all of the tickmarks with their values.</li>\n * </ul>\n * <h4>Notes:<h4>\n * <ul>\n * <li>The right and left handle can be moved individually and their positions could therefore switch.</li>\n * <li>The entire range can be moved along the interval.</li>\n * </ul>\n * <h3>Usage</h3>\n * The most common usecase is to select and move sub-ranges on a continuous numerical scale.\n *\n * <h3>Responsive Behavior</h3>\n * You can move the currently selected range by clicking on it and dragging it along the interval.\n *\n * <h3>ES6 Module Import</h3>\n *\n * <code>import \"@ui5/webcomponents/dist/RangeSlider\";</code>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.RangeSlider\n * @extends SliderBase\n * @tagname ui5-range-slider\n * @since 1.0.0-rc.11\n * @public\n */\nclass RangeSlider extends SliderBase {\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get template() {\n\t\treturn RangeSliderTemplate;\n\t}\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._stateStorage.startValue = null;\n\t\tthis._stateStorage.endValue = null;\n\t\tthis.i18nBundle = getI18nBundle(\"@ui5/webcomponents\");\n\t}\n\n\tget tooltipStartValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.startValue.toFixed(stepPrecision);\n\t}\n\n\tget tooltipEndValue() {\n\t\tconst stepPrecision = this.constructor._getDecimalPrecisionOfNumber(this._effectiveStep);\n\t\treturn this.endValue.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Check if the previously saved state is outdated. That would mean\n\t * either it is the initial rendering or that a property has been changed\n\t * programatically - because the previous state is always updated in\n\t * the interaction handlers.\n\t *\n\t * Normalize current properties, update the previously stored state.\n\t * Update the visual UI representation of the Slider.\n\t *\n\t */\n\tonBeforeRendering() {\n\t\tif (!this.isCurrentStateOutdated()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.notResized = true;\n\t\tthis.syncUIAndState(\"startValue\", \"endValue\");\n\t\tthis._updateHandlesAndRange(null);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider\n\t *\n\t * @private\n\t */\n\t_onmousedown(event) {\n\t\t// If step is 0 no interaction is available because there is no constant\n\t\t// (equal for all user environments) quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate the new value from the press position of the event\n\t\tconst newValue = this.handleDownBase(event);\n\n\t\t// Determine the rest of the needed details from the start of the interaction.\n\t\tthis._saveInteractionStartData(event, newValue);\n\n\t\t// Do not yet update the RangeSlider if press is in range or over a handle.\n\t\tif (this._inCurrentRange || this._handeIsPressed) {\n\t\t\tthis._handeIsPressed = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// Update Slider UI and internal state\n\t\tthis._updateHandlesAndRange(newValue);\n\t\tthis.updateValue(this._valueAffected, newValue);\n\t\tthis.storePropertyState(this._valueAffected);\n\t}\n\n\n\t/**\n\t * Determines and saves needed values from the start of the interaction:\n\t *\n\t * Is the value calculated is within the currently selected range;\n\t * Initial pageX position of the start handle affected by the interaction;\n\t * Initial pageX value of the pressed postion;\n\t * Affected value property by the action;\n\t *\n\t * @private\n\t */\n\t_saveInteractionStartData(event, newValue) {\n\t\tconst progressBarDom = this.shadowRoot.querySelector(\".ui5-slider-progress\").getBoundingClientRect();\n\n\t\t// Save the state of the value properties on the start of the interaction\n\t\tthis._prevStartValue = this.startValue;\n\t\tthis._prevEndValue = this.endValue;\n\n\t\t// Check if the new value is in the current select range of values\n\t\tthis._inCurrentRange = newValue > this._prevStartValue && newValue < this._prevEndValue;\n\t\t// Save the initial press point coordinates (position)\n\t\tthis._initialPageXPosition = this.constructor.getPageXValueFromEvent(event);\n\t\t// Which element of the Range Slider is pressed and which value property to be modified on further interaction\n\t\tthis._pressTargetAndAffectedValue(this._initialPageXPosition, newValue);\n\n\t\t// Use the progress bar to save the initial coordinates of the start-handle when the interaction begins.\n\t\t// We will use it as a reference to calculate a moving offset if the whole range selection is dragged.\n\t\tthis._initialStartHandlePageX = this.directionStart === \"left\" ? progressBarDom.left : progressBarDom.right;\n\t}\n\n\n\t/**\n\t * Called when the user moves the slider\n\t *\n\t * @private\n\t */\n\t_handleMove(event) {\n\t\tevent.preventDefault();\n\n\t\t// If 'step' is 0 no interaction is available as there is no constant quantitative representation of the value\n\t\tif (this.disabled || this._effectiveStep === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Update UI and state when dragging a single Range Slider handle\n\t\tif (!this._inCurrentRange) {\n\t\t\tthis._updateValueOnHandleDrag(event);\n\t\t\treturn;\n\t\t}\n\n\t\t// Updates UI and state when dragging of the whole selected range\n\t\tthis._updateValueOnRangeDrag(event);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging a single Range Slider handle\n\t *\n\t * @private\n\t */\n\t_updateValueOnHandleDrag(event) {\n\t\tconst newValue = this.constructor.getValueFromInteraction(event, this._effectiveStep, this._effectiveMin, this._effectiveMax, this.getBoundingClientRect(), this.directionStart);\n\n\t\tthis._updateHandlesAndRange(newValue);\n\t\tthis.updateValue(this._valueAffected, newValue);\n\t\tthis.storePropertyState(this._valueAffected);\n\t}\n\n\t/**\n\t * Updates UI and state when dragging of the whole selected range\n\t *\n\t * @private\n\t */\n\t_updateValueOnRangeDrag(event) {\n\t\t// Calculate the new 'start' and 'end' values from the offset between the original press point and the current position of the mouse\n\t\tconst currentPageXPos = this.constructor.getPageXValueFromEvent(event);\n\t\tconst newValues = this._calculateRangeOffset(currentPageXPos, this._initialStartHandlePageX);\n\n\t\t// No matter the which value is set as the one to be modified (this._valueAffected) we want to modify both of them\n\t\tthis._valueAffected = null;\n\n\t\t// Update the UI and the state acccording to the calculated new values\n\t\tthis.updateValue(\"startValue\", newValues[0]);\n\t\tthis.updateValue(\"endValue\", newValues[1]);\n\t\tthis._updateHandlesAndRange(null);\n\t\tthis.storePropertyState(\"startValue\", \"endValue\");\n\t}\n\n\t_handleUp() {\n\t\tif (this.startValue !== this._prevStartValue || this.endValue !== this._prevEndValue) {\n\t\t\tthis.fireEvent(\"change\");\n\t\t}\n\n\t\tthis._swapValues();\n\t\tthis.handleUpBase();\n\n\t\tthis._valueAffected = null;\n\t\tthis._prevStartValue = null;\n\t\tthis._prevEndValue = null;\n\t}\n\n\t/**\n\t * Determines where the press occured and which values of the Range Slider\n\t * handles should be updated on further interaction.\n\t *\n\t * If the press is not in the selected range or over one of the Range Slider handles\n\t * determines which one from the value/endValue properties has to be updated\n\t * after the user action (based on closest handle).\n\t *\n\t * Set flags if the press is over a handle or in the selected range,\n\t * in such cases no values are changed on interaction start, but could be\n\t * updated later when dragging.\n\t *\n\t * @private\n\t */\n\t_pressTargetAndAffectedValue(clientX, value) {\n\t\tconst startHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--start\");\n\t\tconst endHandle = this.shadowRoot.querySelector(\".ui5-slider-handle--end\");\n\n\t\t// Check if the press point is in the bounds of any of the Range Slider handles\n\t\tconst handleStartDomRect = startHandle.getBoundingClientRect();\n\t\tconst handleEndDomRect = endHandle.getBoundingClientRect();\n\t\tconst inHandleStartDom = clientX >= handleStartDomRect.left && clientX <= handleStartDomRect.right;\n\t\tconst inHandleEndDom = clientX >= handleEndDomRect.left && clientX <= handleEndDomRect.right;\n\n\t\t// Remove the flag for value in current range if the press action is over one of the handles\n\t\tif (inHandleEndDom || inHandleStartDom) {\n\t\t\tthis._inCurrentRange = false;\n\t\t\tthis._handeIsPressed = true;\n\t\t}\n\n\t\t// Return that handle that is closer to the press point\n\t\tif (inHandleEndDom || value > this.endValue) {\n\t\t\tthis._valueAffected = \"endValue\";\n\t\t}\n\n\t\t// If one of the handle is pressed return that one\n\t\tif (inHandleStartDom || value < this.startValue) {\n\t\t\tthis._valueAffected = \"startValue\";\n\t\t}\n\t}\n\n\t/**\n\t * Calculates startValue/endValue properties when the whole range is moved.\n\t *\n\t * Uses the change of the position of the start handle and adds the initially\n\t * selected range to it, to determine the whole range offset.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateRangeOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\t// Return the current values if there is no difference in the\n\t\t// possitions of the initial press and the current pointer\n\t\tif (this._initialPageXPosition === currentPageXPos) {\n\t\t\treturn [this.startValue, this.endValue];\n\t\t}\n\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst selectedRange = this.endValue - this.startValue;\n\n\t\t// Computes the new value based on the difference of the current cursor location from the start of the interaction\n\t\tlet startValue = this._calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos);\n\n\t\t// When the end handle reaches the max possible value prevent the start handle from moving\n\t\t// And the opposite - if the start handle reaches the beginning of the slider keep the initially selected range.\n\t\tstartValue = this.constructor.clipValue(startValue, min, max - selectedRange);\n\n\t\treturn [startValue, startValue + selectedRange];\n\t}\n\n\t/**\n\t * Computes the new value based on the difference of the current cursor location from the\n\t * start of the interaction.\n\t *\n\t * @param {Integer} currentPageXPos The current horizontal position of the cursor/touch\n\t * @param {Integer} initialStartHandlePageXPos The initial horizontal position of the start handle\n\t *\n\t * @private\n\t */\n\t_calculateStartValueByOffset(currentPageXPos, initialStartHandlePageXPos) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst step = this._effectiveStep;\n\t\tconst dom = this.getBoundingClientRect();\n\n\t\tlet startValue;\n\t\tlet startValuePageX;\n\t\tlet positionOffset;\n\n\t\t/* Depending on the dragging direction:\n\t\t- calculate the new position of the start handle from its old pageX value combined with the movement offset;\n\t\t- calculate the start value based on its new pageX coordinates;\n\t\t- 'stepify' the calculated value based on the specified step property; */\n\t\tif (currentPageXPos > this._initialPageXPosition) {\n\t\t\t// Difference between the new position of the pointer and when the press event initial occured\n\t\t\tpositionOffset = currentPageXPos - this._initialPageXPosition;\n\n\t\t\tstartValuePageX = initialStartHandlePageXPos + positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t} else {\n\t\t\tpositionOffset = this._initialPageXPosition - currentPageXPos;\n\t\t\tstartValuePageX = initialStartHandlePageXPos - positionOffset;\n\t\t\tstartValue = this.constructor.computedValueFromPageX(startValuePageX, min, max, dom, this.directionStart);\n\t\t\tstartValue = this.constructor.getSteppedValue(startValue, step, min);\n\t\t}\n\n\t\treturn startValue;\n\t}\n\n\t_updateHandlesAndRange(newValue) {\n\t\tconst max = this._effectiveMax;\n\t\tconst min = this._effectiveMin;\n\t\tconst prevStartValue = this.getStoredPropertyState(\"startValue\");\n\t\tconst prevEndValue = this.getStoredPropertyState(\"endValue\");\n\n\t\t// The value according to which we update the UI can be either the startValue\n\t\t// or the endValue property. It is determined in _getClosestHandle()\n\t\t// depending on to which handle is closer the user interaction.\n\t\tif (this._valueAffected === \"startValue\") {\n\t\t\t// When the value changing is the start value:\n\t\t\tthis._selectedRange = (prevEndValue - newValue) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((newValue - min) / (max - min)) * 100;\n\t\t} else if (this._valueAffected === \"endValue\") {\n\t\t\t// Wen the value changing is the end value:\n\t\t\tthis._selectedRange = ((newValue - prevStartValue)) / (max - min);\n\t\t\tthis._secondHandlePositionFromStart = (newValue - min) / (max - min) * 100;\n\t\t} else {\n\t\t\t// When both values are changed - UI sync or moving the whole selected range:\n\t\t\tthis._selectedRange = ((this.endValue - this.startValue)) / (max - min);\n\t\t\tthis._firstHandlePositionFromStart = ((this.startValue - min) / (max - min)) * 100;\n\t\t\tthis._secondHandlePositionFromStart = (this.endValue - min) / (max - min) * 100;\n\t\t}\n\t}\n\n\t/**\n\t * Swaps start and end values and handles (thumbs), if one came accros the other\n\t *\n\t * @private\n\t */\n\t_swapValues() {\n\t\t// If the start value is greater than the endValue swap them and their handles\n\t\tif (this._valueAffected === \"startValue\" && this.startValue > this.endValue) {\n\t\t\tconst oldEndValue = this.endValue;\n\t\t\tthis.endValue = this.startValue;\n\t\t\tthis.startValue = oldEndValue;\n\t\t\treturn;\n\t\t}\n\n\t\t// If the endValue become less than the start value swap them and their handles\n\t\tif (this._valueAffected === \"endValue\" && this.endValue < this.startValue) {\n\t\t\tconst oldStartValue = this.startValue;\n\t\t\tthis.startValue = this.endValue;\n\t\t\tthis.endValue = oldStartValue;\n\t\t}\n\t}\n\n\tget styles() {\n\t\treturn {\n\t\t\tprogress: {\n\t\t\t\t\"transform\": `scaleX(${this._selectedRange})`,\n\t\t\t\t\"transform-origin\": `${this.directionStart} top`,\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tstartHandle: {\n\t\t\t\t[this.directionStart]: `${this._firstHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\tendHandle: {\n\t\t\t\t[this.directionStart]: `${this._secondHandlePositionFromStart}%`,\n\t\t\t},\n\t\t\ttickmarks: {\n\t\t\t\t\"background\": `${this._tickmarks}`,\n\t\t\t},\n\t\t\tlabel: {\n\t\t\t\t\"width\": `${this._labelWidth}%`,\n\t\t\t},\n\t\t\tlabelContainer: {\n\t\t\t\t\"width\": `100%`,\n\t\t\t\t[this.directionStart]: `-${this._labelWidth / 2}%`,\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\t\"visibility\": `${this._tooltipVisibility}`,\n\t\t\t},\n\t\t};\n\t}\n\n\tstatic async onDefine() {\n\t\tawait fetchI18nBundle(\"@ui5/webcomponents\");\n\t}\n}\n\nRangeSlider.define();\n\nexport default RangeSlider;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}