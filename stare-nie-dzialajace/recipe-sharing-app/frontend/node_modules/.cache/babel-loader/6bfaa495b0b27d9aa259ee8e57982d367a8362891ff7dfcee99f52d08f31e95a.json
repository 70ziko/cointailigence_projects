{"ast":null,"code":"import React from 'react';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n  if (b === void 0) {\n    b = {};\n  }\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\nvar observedNodes = /*#__PURE__*/new Map();\nvar rafId;\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nfunction useRect(nodeRef) {\n  var _React$useState = React.useState(nodeRef.current),\n    element = _React$useState[0],\n    setElement = _React$useState[1];\n  var _React$useReducer = React.useReducer(rectReducer, null),\n    rect = _React$useReducer[0],\n    dispatch = _React$useReducer[1];\n  var initialRectSet = React.useRef(false);\n  useIsomorphicLayoutEffect(function () {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current);\n    }\n  });\n  useIsomorphicLayoutEffect(function () {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true;\n      var _rect = element.getBoundingClientRect();\n      dispatch({\n        rect: _rect\n      });\n    }\n  }, [element]);\n  React.useEffect(function () {\n    if (!element) {\n      return;\n    }\n    var observer = observeRect(element, function (rect) {\n      dispatch({\n        rect: rect\n      });\n    });\n    observer.observe();\n    return function () {\n      observer.unobserve();\n    };\n  }, [element]);\n  return rect;\n}\nfunction rectReducer(state, action) {\n  var rect = action.rect;\n  if (!state || state.height !== rect.height || state.width !== rect.width) {\n    return rect;\n  }\n  return state;\n}\nvar defaultEstimateSize = function defaultEstimateSize() {\n  return 50;\n};\nfunction useVirtual(_ref) {\n  var _ref3, _measurements;\n  var _ref$size = _ref.size,\n    size = _ref$size === void 0 ? 0 : _ref$size,\n    _ref$estimateSize = _ref.estimateSize,\n    estimateSize = _ref$estimateSize === void 0 ? defaultEstimateSize : _ref$estimateSize,\n    _ref$overscan = _ref.overscan,\n    overscan = _ref$overscan === void 0 ? 0 : _ref$overscan,\n    _ref$paddingStart = _ref.paddingStart,\n    paddingStart = _ref$paddingStart === void 0 ? 0 : _ref$paddingStart,\n    _ref$paddingEnd = _ref.paddingEnd,\n    paddingEnd = _ref$paddingEnd === void 0 ? 0 : _ref$paddingEnd,\n    parentRef = _ref.parentRef,\n    horizontal = _ref.horizontal,\n    scrollToFn = _ref.scrollToFn,\n    useObserver = _ref.useObserver,\n    onScrollElement = _ref.onScrollElement,\n    scrollOffsetFn = _ref.scrollOffsetFn;\n  var sizeKey = horizontal ? 'width' : 'height';\n  var scrollKey = horizontal ? 'scrollLeft' : 'scrollTop';\n  var latestRef = React.useRef({});\n  var useMeasureParent = useObserver || useRect;\n  var _ref2 = useMeasureParent(parentRef) || (_ref3 = {}, _ref3[sizeKey] = 0, _ref3),\n    outerSize = _ref2[sizeKey];\n  var defaultScrollToFn = React.useCallback(function (offset) {\n    if (parentRef.current) {\n      parentRef.current[scrollKey] = offset;\n    }\n  }, [parentRef, scrollKey]);\n  var resolvedScrollToFn = scrollToFn || defaultScrollToFn;\n  scrollToFn = React.useCallback(function (offset) {\n    resolvedScrollToFn(offset, defaultScrollToFn);\n  }, [defaultScrollToFn, resolvedScrollToFn]);\n  var _React$useState = React.useState({}),\n    measuredCache = _React$useState[0],\n    setMeasuredCache = _React$useState[1];\n  var measurements = React.useMemo(function () {\n    var measurements = [];\n    for (var i = 0; i < size; i++) {\n      var measuredSize = measuredCache[i];\n      var start = measurements[i - 1] ? measurements[i - 1].end : paddingStart;\n      var _size = typeof measuredSize === 'number' ? measuredSize : estimateSize(i);\n      var end = start + _size;\n      measurements[i] = {\n        index: i,\n        start: start,\n        size: _size,\n        end: end\n      };\n    }\n    return measurements;\n  }, [estimateSize, measuredCache, paddingStart, size]);\n  var totalSize = (((_measurements = measurements[size - 1]) == null ? void 0 : _measurements.end) || 0) + paddingEnd;\n  Object.assign(latestRef.current, {\n    overscan: overscan,\n    measurements: measurements,\n    outerSize: outerSize,\n    totalSize: totalSize\n  });\n  var _React$useState2 = React.useState({\n      start: 0,\n      end: 0\n    }),\n    range = _React$useState2[0],\n    setRange = _React$useState2[1];\n  var element = onScrollElement ? onScrollElement.current : parentRef.current;\n  useIsomorphicLayoutEffect(function () {\n    if (!element) {\n      return;\n    }\n    var onScroll = function onScroll() {\n      var scrollOffset = scrollOffsetFn ? scrollOffsetFn() : element[scrollKey];\n      latestRef.current.scrollOffset = scrollOffset;\n      setRange(function (prevRange) {\n        return calculateRange(latestRef.current, prevRange);\n      });\n    }; // Determine initially visible range\n\n    onScroll();\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true\n    });\n    return function () {\n      element.removeEventListener('scroll', onScroll);\n    };\n  }, [element, scrollKey, size\n  /* required */, outerSize\n  /* required */]);\n\n  var virtualItems = React.useMemo(function () {\n    var virtualItems = [];\n    var end = Math.min(range.end, measurements.length - 1);\n    var _loop = function _loop(i) {\n      var measurement = measurements[i];\n      var item = _extends(_extends({}, measurement), {}, {\n        measureRef: function measureRef(el) {\n          var scrollOffset = latestRef.current.scrollOffset;\n          if (el) {\n            var _el$getBoundingClient = el.getBoundingClientRect(),\n              measuredSize = _el$getBoundingClient[sizeKey];\n            if (measuredSize !== item.size) {\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size));\n              }\n              setMeasuredCache(function (old) {\n                var _extends2;\n                return _extends(_extends({}, old), {}, (_extends2 = {}, _extends2[i] = measuredSize, _extends2));\n              });\n            }\n          }\n        }\n      });\n      virtualItems.push(item);\n    };\n    for (var i = range.start; i <= end; i++) {\n      _loop(i);\n    }\n    return virtualItems;\n  }, [range.start, range.end, measurements, sizeKey, defaultScrollToFn]);\n  var mountedRef = React.useRef();\n  useIsomorphicLayoutEffect(function () {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({});\n    }\n    mountedRef.current = true;\n  }, [estimateSize, size]);\n  var scrollToOffset = React.useCallback(function (toOffset, _temp) {\n    var _ref4 = _temp === void 0 ? {} : _temp,\n      _ref4$align = _ref4.align,\n      align = _ref4$align === void 0 ? 'start' : _ref4$align;\n    var _latestRef$current = latestRef.current,\n      scrollOffset = _latestRef$current.scrollOffset,\n      outerSize = _latestRef$current.outerSize;\n    if (align === 'auto') {\n      if (toOffset <= scrollOffset) {\n        align = 'start';\n      } else if (scrollOffset >= scrollOffset + outerSize) {\n        align = 'end';\n      } else {\n        align = 'start';\n      }\n    }\n    if (align === 'start') {\n      scrollToFn(toOffset);\n    } else if (align === 'end') {\n      scrollToFn(toOffset - outerSize);\n    } else if (align === 'center') {\n      scrollToFn(toOffset - outerSize / 2);\n    }\n  }, [scrollToFn]);\n  var tryScrollToIndex = React.useCallback(function (index, _temp2) {\n    var _ref5 = _temp2 === void 0 ? {} : _temp2,\n      _ref5$align = _ref5.align,\n      align = _ref5$align === void 0 ? 'auto' : _ref5$align,\n      rest = _objectWithoutPropertiesLoose(_ref5, [\"align\"]);\n    var _latestRef$current2 = latestRef.current,\n      measurements = _latestRef$current2.measurements,\n      scrollOffset = _latestRef$current2.scrollOffset,\n      outerSize = _latestRef$current2.outerSize;\n    var measurement = measurements[Math.max(0, Math.min(index, size - 1))];\n    if (!measurement) {\n      return;\n    }\n    if (align === 'auto') {\n      if (measurement.end >= scrollOffset + outerSize) {\n        align = 'end';\n      } else if (measurement.start <= scrollOffset) {\n        align = 'start';\n      } else {\n        return;\n      }\n    }\n    var toOffset = align === 'center' ? measurement.start + measurement.size / 2 : align === 'end' ? measurement.end : measurement.start;\n    scrollToOffset(toOffset, _extends({\n      align: align\n    }, rest));\n  }, [scrollToOffset, size]);\n  var scrollToIndex = React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // We do a double request here because of\n    // dynamic sizes which can cause offset shift\n    // and end up in the wrong spot. Unfortunately,\n    // we can't know about those dynamic sizes until\n    // we try and render them. So double down!\n    tryScrollToIndex.apply(void 0, args);\n    requestAnimationFrame(function () {\n      tryScrollToIndex.apply(void 0, args);\n    });\n  }, [tryScrollToIndex]);\n  return {\n    virtualItems: virtualItems,\n    totalSize: totalSize,\n    scrollToOffset: scrollToOffset,\n    scrollToIndex: scrollToIndex\n  };\n}\nfunction calculateRange(_ref6, prevRange) {\n  var overscan = _ref6.overscan,\n    measurements = _ref6.measurements,\n    outerSize = _ref6.outerSize,\n    scrollOffset = _ref6.scrollOffset;\n  var total = measurements.length;\n  var start = total - 1;\n  while (start > 0 && measurements[start].end >= scrollOffset) {\n    start -= 1;\n  }\n  var end = 0;\n  while (end < total - 1 && measurements[end].start <= scrollOffset + outerSize) {\n    end += 1;\n  } // Always add at least one overscan item, so focus will work\n\n  start = Math.max(start - overscan, 0);\n  end = Math.min(end + overscan, total - 1);\n  if (!prevRange || prevRange.start !== start || prevRange.end !== end) {\n    return {\n      start: start,\n      end: end\n    };\n  }\n  return prevRange;\n}\nexport { useVirtual };","map":{"version":3,"names":["props","rectChanged","a","b","some","prop","observedNodes","Map","rafId","run","changedStates","forEach","state","node","newRect","getBoundingClientRect","rect","push","callbacks","cb","window","requestAnimationFrame","observeRect","observe","wasEmpty","size","has","get","set","undefined","hasRectChanged","unobserve","index","indexOf","splice","length","cancelAnimationFrame","useIsomorphicLayoutEffect","React","useLayoutEffect","useEffect","useRect","nodeRef","_React$useState","useState","current","element","setElement","_React$useReducer","useReducer","rectReducer","dispatch","initialRectSet","useRef","_rect","observer","action","height","width","defaultEstimateSize","useVirtual","_ref","_ref3","_measurements","_ref$size","_ref$estimateSize","estimateSize","_ref$overscan","overscan","_ref$paddingStart","paddingStart","_ref$paddingEnd","paddingEnd","parentRef","horizontal","scrollToFn","useObserver","onScrollElement","scrollOffsetFn","sizeKey","scrollKey","latestRef","useMeasureParent","_ref2","outerSize","defaultScrollToFn","useCallback","offset","resolvedScrollToFn","measuredCache","setMeasuredCache","measurements","useMemo","i","measuredSize","start","end","_size","totalSize","Object","assign","_React$useState2","range","setRange","onScroll","scrollOffset","prevRange","calculateRange","addEventListener","capture","passive","removeEventListener","virtualItems","Math","min","_loop","measurement","item","_extends","measureRef","el","_el$getBoundingClient","old","_extends2","mountedRef","scrollToOffset","toOffset","_temp","_ref4","_ref4$align","align","_latestRef$current","tryScrollToIndex","_temp2","_ref5","_ref5$align","rest","_objectWithoutPropertiesLoose","_latestRef$current2","max","scrollToIndex","_len","arguments","args","Array","_key","apply","_ref6","total"],"sources":["/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/react-virtual/node_modules/@reach/observe-rect/dist/observe-rect.esm.js","/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/react-virtual/src/useIsomorphicLayoutEffect.js","/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/react-virtual/src/useRect.js","/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/react-virtual/src/index.js"],"sourcesContent":["var props = ['bottom', 'height', 'left', 'right', 'top', 'width'];\n\nvar rectChanged = function rectChanged(a, b) {\n  if (a === void 0) {\n    a = {};\n  }\n\n  if (b === void 0) {\n    b = {};\n  }\n\n  return props.some(function (prop) {\n    return a[prop] !== b[prop];\n  });\n};\n\nvar observedNodes =\n/*#__PURE__*/\nnew Map();\nvar rafId;\n\nvar run = function run() {\n  var changedStates = [];\n  observedNodes.forEach(function (state, node) {\n    var newRect = node.getBoundingClientRect();\n\n    if (rectChanged(newRect, state.rect)) {\n      state.rect = newRect;\n      changedStates.push(state);\n    }\n  });\n  changedStates.forEach(function (state) {\n    state.callbacks.forEach(function (cb) {\n      return cb(state.rect);\n    });\n  });\n  rafId = window.requestAnimationFrame(run);\n};\n\nfunction observeRect(node, cb) {\n  return {\n    observe: function observe() {\n      var wasEmpty = observedNodes.size === 0;\n\n      if (observedNodes.has(node)) {\n        observedNodes.get(node).callbacks.push(cb);\n      } else {\n        observedNodes.set(node, {\n          rect: undefined,\n          hasRectChanged: false,\n          callbacks: [cb]\n        });\n      }\n\n      if (wasEmpty) run();\n    },\n    unobserve: function unobserve() {\n      var state = observedNodes.get(node);\n\n      if (state) {\n        // Remove the callback\n        var index = state.callbacks.indexOf(cb);\n        if (index >= 0) state.callbacks.splice(index, 1); // Remove the node reference\n\n        if (!state.callbacks.length) observedNodes[\"delete\"](node); // Stop the loop\n\n        if (!observedNodes.size) cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\n\nexport default observeRect;\n//# sourceMappingURL=observe-rect.esm.js.map\n","import React from 'react'\n\nexport default typeof window !== 'undefined'\n  ? React.useLayoutEffect\n  : React.useEffect\n","import React from 'react'\n\nimport observeRect from '@reach/observe-rect'\n\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nexport default function useRect(nodeRef) {\n  const [element, setElement] = React.useState(nodeRef.current)\n  const [rect, dispatch] = React.useReducer(rectReducer, null)\n  const initialRectSet = React.useRef(false)\n\n  useIsomorphicLayoutEffect(() => {\n    if (nodeRef.current !== element) {\n      setElement(nodeRef.current)\n    }\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    if (element && !initialRectSet.current) {\n      initialRectSet.current = true\n      const rect = element.getBoundingClientRect();\n      dispatch({ rect });\n    }\n  }, [element])\n\n  React.useEffect(() => {\n    if (!element) {\n      return\n    }\n\n    const observer = observeRect(element, rect => {\n      dispatch({ rect });\n    });\n\n    observer.observe()\n\n    return () => {\n      observer.unobserve()\n    }\n  }, [element])\n\n  return rect\n}\n\nfunction rectReducer(state, action) {\n  const rect = action.rect\n  if (!state || state.height !== rect.height || state.width !== rect.width) {\n    return rect\n  }\n  return state\n}\n\n","import React from 'react'\n\nimport useRect from './useRect'\nimport useIsomorphicLayoutEffect from './useIsomorphicLayoutEffect'\n\nconst defaultEstimateSize = () => 50\n\nexport function useVirtual({\n  size = 0,\n  estimateSize = defaultEstimateSize,\n  overscan = 0,\n  paddingStart = 0,\n  paddingEnd = 0,\n  parentRef,\n  horizontal,\n  scrollToFn,\n  useObserver,\n  onScrollElement,\n  scrollOffsetFn,\n}) {\n  const sizeKey = horizontal ? 'width' : 'height'\n  const scrollKey = horizontal ? 'scrollLeft' : 'scrollTop'\n  const latestRef = React.useRef({})\n  const useMeasureParent = useObserver || useRect\n\n  const { [sizeKey]: outerSize } = useMeasureParent(parentRef) || {\n    [sizeKey]: 0,\n  }\n\n  const defaultScrollToFn = React.useCallback(\n    offset => {\n      if (parentRef.current) {\n        parentRef.current[scrollKey] = offset\n      }\n    },\n    [parentRef, scrollKey]\n  )\n\n  const resolvedScrollToFn = scrollToFn || defaultScrollToFn\n\n  scrollToFn = React.useCallback(\n    offset => {\n      resolvedScrollToFn(offset, defaultScrollToFn)\n    },\n    [defaultScrollToFn, resolvedScrollToFn]\n  )\n\n  const [measuredCache, setMeasuredCache] = React.useState({})\n\n  const measurements = React.useMemo(() => {\n    const measurements = []\n    for (let i = 0; i < size; i++) {\n      const measuredSize = measuredCache[i]\n      const start = measurements[i - 1] ? measurements[i - 1].end : paddingStart\n      const size =\n        typeof measuredSize === 'number' ? measuredSize : estimateSize(i)\n      const end = start + size\n      measurements[i] = { index: i, start, size, end }\n    }\n    return measurements\n  }, [estimateSize, measuredCache, paddingStart, size])\n\n  const totalSize = (measurements[size - 1]?.end || 0) + paddingEnd\n\n  Object.assign(latestRef.current, {\n    overscan,\n    measurements,\n    outerSize,\n    totalSize,\n  })\n\n  const [range, setRange] = React.useState({ start: 0, end: 0 })\n\n  const element = onScrollElement ? onScrollElement.current : parentRef.current\n  useIsomorphicLayoutEffect(() => {\n    if (!element) { return }\n\n    const onScroll = () => {\n      const scrollOffset = scrollOffsetFn ? scrollOffsetFn() : element[scrollKey]\n      latestRef.current.scrollOffset = scrollOffset\n      setRange(prevRange => calculateRange(latestRef.current, prevRange))\n    }\n\n    // Determine initially visible range\n    onScroll()\n\n    element.addEventListener('scroll', onScroll, {\n      capture: false,\n      passive: true,\n    })\n\n    return () => {\n      element.removeEventListener('scroll', onScroll)\n    }\n  }, [element, scrollKey, size /* required */, outerSize /* required */])\n\n  const virtualItems = React.useMemo(() => {\n    const virtualItems = []\n    const end = Math.min(range.end, measurements.length - 1)\n\n    for (let i = range.start; i <= end; i++) {\n      const measurement = measurements[i]\n\n      const item = {\n        ...measurement,\n        measureRef: el => {\n          const { scrollOffset } = latestRef.current\n\n          if (el) {\n            const { [sizeKey]: measuredSize } = el.getBoundingClientRect()\n\n            if (measuredSize !== item.size) {\n              if (item.start < scrollOffset) {\n                defaultScrollToFn(scrollOffset + (measuredSize - item.size))\n              }\n\n              setMeasuredCache(old => ({\n                ...old,\n                [i]: measuredSize,\n              }))\n            }\n          }\n        },\n      }\n\n      virtualItems.push(item)\n    }\n\n    return virtualItems\n  }, [range.start, range.end, measurements, sizeKey, defaultScrollToFn])\n\n  const mountedRef = React.useRef()\n\n  useIsomorphicLayoutEffect(() => {\n    if (mountedRef.current) {\n      if (estimateSize || size) setMeasuredCache({})\n    }\n    mountedRef.current = true\n  }, [estimateSize, size])\n\n  const scrollToOffset = React.useCallback(\n    (toOffset, { align = 'start' } = {}) => {\n      const { scrollOffset, outerSize } = latestRef.current\n\n      if (align === 'auto') {\n        if (toOffset <= scrollOffset) {\n          align = 'start'\n        } else if (scrollOffset >= scrollOffset + outerSize) {\n          align = 'end'\n        } else {\n          align = 'start'\n        }\n      }\n\n      if (align === 'start') {\n        scrollToFn(toOffset)\n      } else if (align === 'end') {\n        scrollToFn(toOffset - outerSize)\n      } else if (align === 'center') {\n        scrollToFn(toOffset - outerSize / 2)\n      }\n    },\n    [scrollToFn]\n  )\n\n  const tryScrollToIndex = React.useCallback(\n    (index, { align = 'auto', ...rest } = {}) => {\n      const { measurements, scrollOffset, outerSize } = latestRef.current\n\n      const measurement = measurements[Math.max(0, Math.min(index, size - 1))]\n\n      if (!measurement) {\n        return\n      }\n\n      if (align === 'auto') {\n        if (measurement.end >= scrollOffset + outerSize) {\n          align = 'end'\n        } else if (measurement.start <= scrollOffset) {\n          align = 'start'\n        } else {\n          return\n        }\n      }\n\n      const toOffset =\n        align === 'center'\n          ? measurement.start + measurement.size / 2\n          : align === 'end'\n            ? measurement.end\n            : measurement.start\n\n      scrollToOffset(toOffset, { align, ...rest })\n    },\n    [scrollToOffset, size]\n  )\n\n  const scrollToIndex = React.useCallback(\n    (...args) => {\n      // We do a double request here because of\n      // dynamic sizes which can cause offset shift\n      // and end up in the wrong spot. Unfortunately,\n      // we can't know about those dynamic sizes until\n      // we try and render them. So double down!\n      tryScrollToIndex(...args)\n      requestAnimationFrame(() => {\n        tryScrollToIndex(...args)\n      })\n    },\n    [tryScrollToIndex]\n  )\n\n  return {\n    virtualItems,\n    totalSize,\n    scrollToOffset,\n    scrollToIndex,\n  }\n}\n\nfunction calculateRange({\n  overscan,\n  measurements,\n  outerSize,\n  scrollOffset,\n}, prevRange) {\n  const total = measurements.length\n  let start = total - 1\n  while (start > 0 && measurements[start].end >= scrollOffset) {\n    start -= 1\n  }\n  let end = 0\n  while (end < total - 1 && measurements[end].start <= scrollOffset + outerSize) {\n    end += 1\n  }\n\n  // Always add at least one overscan item, so focus will work\n  start = Math.max(start - overscan, 0)\n  end = Math.min(end + overscan, total - 1)\n\n  if (!prevRange || prevRange.start !== start || prevRange.end !== end) {\n    return { start, end }\n  }\n\n  return prevRange\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}