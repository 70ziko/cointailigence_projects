{"ast":null,"code":"import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n  properties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */{\n    /**\n     * Defines the minimum value of the slider\n     *\n     * @type {Float}\n     * @defaultvalue 0\n     * @public\n     */\n    min: {\n      type: Float,\n      defaultValue: 0\n    },\n    /**\n     * Defines the maximum value of the slider\n     *\n     * @type {Float}\n     * @defaultvalue 100\n     * @public\n     */\n    max: {\n      type: Float,\n      defaultValue: 100\n    },\n    /**\n     * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n     * <br><br>\n     * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n     *\n     * @type {Integer}\n     * @defaultvalue 1\n     * @public\n     */\n    step: {\n      type: Float,\n      defaultValue: 1\n    },\n    /**\n     * Displays a label with a value on every N-th step.\n     * <br><br>\n     * <b>Note:</b> The step and tickmarks properties must be enabled.\n     * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n     * tickmark will be labelled, which means every 4th value number.\n     *\n     * @type {Integer}\n     * @defaultvalue 0\n     * @public\n     */\n    labelInterval: {\n      type: Integer,\n      defaultValue: 0\n    },\n    /**\n     * Enables tick marks visualization for each step.\n     * <br><br>\n     * <b>Note:</b> The step must be a positive number.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTickmarks: {\n      type: Boolean\n    },\n    /**\n     * Enables handle tooltip displaying the current value.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    showTooltip: {\n      type: Boolean\n    },\n    /**\n     * Defines whether the slider is in disabled state.\n     *\n     * @type {boolean}\n     * @defaultvalue false\n     * @public\n     */\n    disabled: {\n      type: Boolean\n    },\n    /**\n     * @private\n     */\n    _tooltipVisibility: {\n      type: String,\n      defaultValue: \"hidden\"\n    },\n    _labelsOverlapping: {\n      type: Boolean\n    },\n    _hiddenTickmarks: {\n      type: Boolean\n    }\n  },\n  events: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */{\n    /**\n     * Fired when the value changes and the user has finished interacting with the slider.\n     *\n     * @event\n     * @public\n    */\n    change: {},\n    /**\n     * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n     *\n     * @event\n     * @public\n    */\n    input: {}\n  }\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n  constructor() {\n    super();\n    this._resizeHandler = this._handleResize.bind(this);\n    this._moveHandler = this._handleMove.bind(this);\n    this._upHandler = this._handleUp.bind(this);\n    this._stateStorage = {\n      step: null,\n      min: null,\n      max: null,\n      labelInterval: null\n    };\n  }\n  static get metadata() {\n    return metadata;\n  }\n  static get render() {\n    return litRender;\n  }\n  static get styles() {\n    return styles;\n  }\n  static get TICKMARK_COLOR_MAP() {\n    return {\n      sap_fiori_3: \"#89919a\",\n      sap_fiori_3_dark: \"#89919a\",\n      sap_fiori_3_hcw: \"#000000\",\n      sap_fiori_3_hcb: \"#ffffff\",\n      sap_belize: \"#bfbfbf\",\n      sap_belize_hcw: \"#000000\",\n      sap_belize_hcb: \"#ffffff\"\n    };\n  }\n  static get UP_EVENTS() {\n    return [\"mouseup\", \"touchend\"];\n  }\n  static get MOVE_EVENT_MAP() {\n    return {\n      mousedown: \"mousemove\",\n      touchstart: \"touchmove\"\n    };\n  }\n  static get MIN_SPACE_BETWEEN_TICKMARKS() {\n    return 8;\n  }\n  get classes() {\n    return {\n      labelContainer: {\n        \"ui5-slider-hidden-labels\": this._labelsOverlapping\n      }\n    };\n  }\n  onEnterDOM() {\n    ResizeHandler.register(this, this._resizeHandler);\n  }\n  onExitDOM() {\n    ResizeHandler.deregister(this, this._handleResize);\n  }\n  onAfterRendering() {\n    // Only call if the resize is triggered by a state changes other than\n    // the ones that occured on the previous resize and those caused by user interaction.\n    if (this.notResized) {\n      this._resizeHandler();\n    }\n  }\n  _ontouchstart(event) {\n    this._onmousedown(event);\n  }\n\n  /** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n  _onmouseover(event) {\n    if (this.showTooltip) {\n      this._tooltipVisibility = \"visible\";\n    }\n  }\n\n  /**\n   * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n   *\n   * @private\n   */\n  _onmouseout(event) {\n    if (this.showTooltip) {\n      this._tooltipVisibility = \"hidden\";\n    }\n  }\n\n  /**\n   * Handle the responsiveness of the Slider's UI elements when resizing\n   *\n   * @private\n   */\n  _handleResize() {\n    if (!this.showTickmarks) {\n      return;\n    }\n\n    // Mark resizing to avoid unneccessary calls to that function after rendering\n    this.notResized = false;\n\n    // Convert the string represented calculation expression to a normal one\n    // Check the distance  in pixels exist between every tickmark\n    const spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n    // If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n    // In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n    if (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n      this._hiddenTickmarks = true;\n      this._labelsOverlapping = true;\n    } else {\n      this._hiddenTickmarks = false;\n    }\n    if (this.labelInterval <= 0 || this._hiddenTickmarks) {\n      return;\n    }\n\n    // Check if there are any overlapping labels.\n    // If so - only the first and the last one should be visible\n    const labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n    this._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n  }\n\n  /**\n   * Called when the user starts interacting with the slider.\n   * After a down event on the slider root, listen for move events on window, so the slider value\n   * is updated even if the user drags the pointer outside the slider root.\n   *\n   * @protected\n   */\n  handleDownBase(event) {\n    const min = this._effectiveMin;\n    const max = this._effectiveMax;\n    const domRect = this.getBoundingClientRect();\n    const directionStart = this.directionStart;\n    const step = this._effectiveStep;\n    const newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n    if (isPhone() && this.showTooltip) {\n      this._tooltipVisibility = \"visible\";\n    }\n\n    // Mark start of a user interaction\n    this._isUserInteraction = true;\n    // Only allow one type of move event to be listened to (the first one registered after the down event)\n    this._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n    SliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n    window.addEventListener(this._moveEventType, this._moveHandler);\n    return newValue;\n  }\n\n  /**\n   * Called when the user finish interacting with the slider\n   * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n   *\n   * @protected\n   */\n  handleUpBase(valueType) {\n    if (isPhone() && this.showTooltip) {\n      this._tooltipVisibility = \"hidden\";\n    }\n    SliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n    window.removeEventListener(this._moveEventType, this._moveHandler);\n    this._moveEventType = null;\n    this._isUserInteraction = false;\n  }\n\n  /**\n   * Updates value property of the component that has been changed due to a user action.\n   * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n   *\n   * @protected\n   */\n  updateValue(valueType, value) {\n    this[valueType] = value;\n    this.storePropertyState(valueType);\n    if (this._isUserInteraction) {\n      this.fireEvent(\"input\");\n    }\n  }\n\n  /**\n   * Locks the given value between min and max boundaries based on slider properties\n   *\n   * @protected\n   */\n  static clipValue(value, min, max) {\n    value = Math.min(Math.max(value, min), max);\n    return value;\n  }\n\n  /**\n   * Sets the slider value from an event\n   *\n   * @protected\n   */\n  static getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n    const pageX = this.getPageXValueFromEvent(event);\n    const value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n    const steppedValue = this.getSteppedValue(value, stepSize, min);\n    return this.clipValue(steppedValue, min, max);\n  }\n\n  /**\n   * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n   *\n   * @protected\n   */\n  static getSteppedValue(value, stepSize, min) {\n    const stepModuloValue = Math.abs((value - min) % stepSize);\n    if (stepSize === 0 || stepModuloValue === 0) {\n      return value;\n    }\n\n    // Clip (snap) the new value to the nearest step\n    value = stepModuloValue * 2 >= stepSize ? value + stepSize - stepModuloValue : value - stepModuloValue;\n\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n    return value.toFixed(stepPrecision);\n  }\n\n  /**\n   * Gets pageX value from event on user interaction with the Slider\n   *\n   * @protected\n   */\n  static getPageXValueFromEvent(event) {\n    if (event.targetTouches && event.targetTouches.length > 0) {\n      return event.targetTouches[0].pageX;\n    }\n    return event.pageX;\n  }\n\n  /**\n   * Computes the new value (in %) from the pageX position of the cursor.\n   * Returns the value rounded to a precision of at most 2 digits after decimal point.\n   *\n   * @protected\n   */\n  static computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n    // Determine pageX position relative to the Slider DOM\n    const xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n    // Calculate the percentage complete (the \"progress\")\n    const percentageComplete = xRelativePosition / boundingClientRect.width;\n    // Fit (map) the complete percentage between the min/max value range\n    return min + percentageComplete * (max - min);\n  }\n\n  /**\n   * Calculates the precision (decimal places) of a number, returns 0 if integer\n   * Handles scientific notation cases.\n   * @private\n   */\n  static _getDecimalPrecisionOfNumber(value) {\n    if (Number.isInteger(value)) {\n      return 0;\n    }\n    const match = String(value).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n    return Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n  }\n\n  /**\n   * Normalize current properties, update the previously stored state.\n   *\n   * @protected\n   */\n  syncUIAndState(...values) {\n    // Validate step and update the stored state for the step property.\n    if (this.isPropertyUpdated(\"step\")) {\n      this._validateStep(this.step);\n      this.storePropertyState(\"step\");\n    }\n\n    // Recalculate the tickmarks and labels and update the stored state.\n    if (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n      this.storePropertyState(\"min\", \"max\");\n\n      // Here the value props are changed programatically (not by user interaction)\n      // and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n      // min and max bounderies and update the previous state reference.\n      values.forEach(valueType => {\n        const normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n        this.updateValue(valueType, normalizedValue);\n        this.storePropertyState(valueType);\n      });\n    }\n\n    // Labels must be updated if any of the min/max/step/labelInterval props are changed\n    if (this.labelInterval && this.showTickmarks) {\n      this._createLabels();\n    }\n\n    // Update the stored state for the labelInterval, if changed\n    if (this.isPropertyUpdated(\"labelInterval\")) {\n      this.storePropertyState(\"labelInterval\");\n    }\n  }\n\n  /**\n   * In order to always keep the visual UI representation and the internal\n   * state in sync, the component has a 'state storage' that is updated when the\n   * current state is changed due to a user action.\n   *\n   * Check if the previously saved state is outdated. That would mean\n   * a property has been changed programatically because the previous state\n   * is always updated in the interaction handlers.\n   *\n   * Will return true if any of the properties is not equal to its previously\n   * stored value.\n   *\n   * @protected\n   */\n  isCurrentStateOutdated() {\n    return Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n  }\n\n  /**\n   * Returns the last stored value of a property\n   *\n   * @protected\n   */\n  getStoredPropertyState(property) {\n    return this._stateStorage[property];\n  }\n\n  /**\n   * Check if one or more properties have been updated compared to their last\n   * saved values in the state storage.\n   *\n   * @protected\n   */\n  isPropertyUpdated(...properties) {\n    return properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n  }\n\n  /**\n   * Updates the previously saved in the _stateStorage values of one or more properties.\n   *\n   * @protected\n   */\n  storePropertyState(...props) {\n    props.forEach(property => {\n      this._stateStorage[property] = this[property];\n    });\n  }\n\n  /**\n   * Returns the start side of a direction - left for LTR, right for RTL\n   */\n  get directionStart() {\n    return this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n  }\n\n  /**\n   * Calculates and draws the tickmarks with a CSS gradient style\n   *\n   * @private\n   */\n  get _tickmarks() {\n    if (!this.showTickmarks || !this._effectiveStep) {\n      return;\n    }\n    if (this._hiddenTickmarks) {\n      return `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n    }\n\n    // Convert number values to strings to let the CSS do calculations better\n    // rounding/subpixel behavior\" and the most precise tickmarks distribution\n    const maxStr = String(this._effectiveMax);\n    const minStr = String(this._effectiveMin);\n    const stepStr = String(this._effectiveStep);\n    const tickmarkWidth = \"1px\";\n\n    // There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n    // respect the variable for more than one theme. It has to be set here for now.\n    const currentTheme = getTheme();\n    const currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n    this._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n    this._hiddenTickmarks = false;\n\n    // Transparent CSS gradient background\n    const tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `;\n\n    // Draw the tickmarks as a patern over the gradient background\n    const tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`;\n\n    // Combine to get the complete CSS background gradient property value\n    return `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n  }\n\n  /**\n   * Calculates the labels amout, width and text and creates them\n   *\n   * @private\n   */\n  _createLabels() {\n    if (!this.labelInterval || !this.showTickmarks) {\n      return;\n    }\n    const labelInterval = this.labelInterval;\n    const step = this._effectiveStep;\n    const newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n    // If the required labels are already rendered\n    if (newNumberOfLabels === this._oldNumberOfLabels) {\n      return;\n    }\n    this._oldNumberOfLabels = newNumberOfLabels;\n    this._labelWidth = 100 / newNumberOfLabels;\n    this._labelValues = [];\n\n    // If the step value is not a round number get its precision\n    const stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n    // numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n    // calculation to be precize (exactly the same as the distance between the tickmarks).\n    // That's ok as the loop stop condition is set to an integer, so it will practically\n    // \"floor\" the number of labels anyway.\n    for (let i = 0; i <= newNumberOfLabels; i++) {\n      // Format the label numbers with the same decimal precision as the value of the step property\n      const labelItemNumber = (i * step * labelInterval + this._effectiveMin).toFixed(stepPrecision);\n      this._labelValues.push(labelItemNumber);\n    }\n  }\n  get _labels() {\n    return this._labelValues || [];\n  }\n\n  /**\n   * Calculates space between tickmarks\n   *\n   * @private\n   */\n  _spaceBetweenTickmarks() {\n    const tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n    const tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n    return this.getBoundingClientRect().width / tickmarksAmount;\n  }\n\n  /**\n   * Notify in case of a invalid step value type\n   *\n   * @private\n   */\n  _validateStep(step) {\n    if (step === 0) {\n      console.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n    }\n\n    if (step < 0) {\n      console.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n    }\n\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      console.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n    }\n  }\n\n  /**\n   * Normalizes a new <code>step</code> property value.\n   * If tickmarks are enabled recreates them according to it.\n   *\n   * @private\n   */\n  get _effectiveStep() {\n    let step = this.step;\n    if (step < 0) {\n      step = Math.abs(step);\n    }\n    if (typeof step !== \"number\" || Number.isNaN(step)) {\n      step = 1;\n    }\n    return step;\n  }\n  get _effectiveMin() {\n    return Math.min(this.min, this.max);\n  }\n  get _effectiveMax() {\n    return Math.max(this.min, this.max);\n  }\n}\nexport default SliderBase;","map":{"version":3,"names":["UI5Element","litRender","Float","Integer","ResizeHandler","isPhone","getTheme","styles","metadata","properties","min","type","defaultValue","max","step","labelInterval","showTickmarks","Boolean","showTooltip","disabled","_tooltipVisibility","String","_labelsOverlapping","_hiddenTickmarks","events","change","input","SliderBase","constructor","_resizeHandler","_handleResize","bind","_moveHandler","_handleMove","_upHandler","_handleUp","_stateStorage","render","TICKMARK_COLOR_MAP","sap_fiori_3","sap_fiori_3_dark","sap_fiori_3_hcw","sap_fiori_3_hcb","sap_belize","sap_belize_hcw","sap_belize_hcb","UP_EVENTS","MOVE_EVENT_MAP","mousedown","touchstart","MIN_SPACE_BETWEEN_TICKMARKS","classes","labelContainer","onEnterDOM","register","onExitDOM","deregister","onAfterRendering","notResized","_ontouchstart","event","_onmousedown","_onmouseover","_onmouseout","spaceBetweenTickmarks","_spaceBetweenTickmarks","labelItems","shadowRoot","querySelectorAll","some","label","scrollWidth","clientWidth","handleDownBase","_effectiveMin","_effectiveMax","domRect","getBoundingClientRect","directionStart","_effectiveStep","newValue","getValueFromInteraction","_isUserInteraction","_moveEventType","forEach","upEventType","window","addEventListener","handleUpBase","valueType","removeEventListener","updateValue","value","storePropertyState","fireEvent","clipValue","Math","stepSize","boundingClientRect","pageX","getPageXValueFromEvent","computedValueFromPageX","steppedValue","getSteppedValue","stepModuloValue","abs","stepPrecision","_getDecimalPrecisionOfNumber","toFixed","targetTouches","length","xRelativePosition","percentageComplete","width","Number","isInteger","match","syncUIAndState","values","isPropertyUpdated","_validateStep","normalizedValue","_createLabels","isCurrentStateOutdated","Object","entries","propName","propValue","getStoredPropertyState","property","prop","props","effectiveDir","_tickmarks","maxStr","minStr","stepStr","tickmarkWidth","currentTheme","currentColor","_tickmarksAmount","tickmarksGradientBase","tickmarksGradientdPattern","newNumberOfLabels","_oldNumberOfLabels","_labelWidth","_labelValues","i","labelItemNumber","push","_labels","tickmarksAmountStrCalc","split","tickmarksAmount","console","warn","isNaN"],"sources":["/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/@ui5/webcomponents/dist/SliderBase.js"],"sourcesContent":["import UI5Element from \"@ui5/webcomponents-base/dist/UI5Element.js\";\nimport litRender from \"@ui5/webcomponents-base/dist/renderer/LitRenderer.js\";\nimport Float from \"@ui5/webcomponents-base/dist/types/Float.js\";\nimport Integer from \"@ui5/webcomponents-base/dist/types/Integer.js\";\nimport ResizeHandler from \"@ui5/webcomponents-base/dist/delegate/ResizeHandler.js\";\nimport { isPhone } from \"@ui5/webcomponents-base/dist/Device.js\";\n\nimport { getTheme } from \"@ui5/webcomponents-base/dist/config/Theme.js\";\n\n// Styles\nimport styles from \"./generated/themes/SliderBase.css.js\";\n\n/**\n * @public\n */\nconst metadata = {\n\tproperties: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */  {\n\t\t/**\n\t\t * Defines the minimum value of the slider\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tmin: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Defines the maximum value of the slider\n\t\t *\n\t\t * @type {Float}\n\t\t * @defaultvalue 100\n\t\t * @public\n\t\t */\n\t\tmax: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 100,\n\t\t},\n\t\t/**\n\t\t * Defines the size of the slider's selection intervals (e.g. min = 0, max = 10, step = 5 would result in possible selection of the values 0, 5, 10).\n\t\t * <br><br>\n\t\t * <b>Note:</b> If set to 0 the slider handle movement is disabled. When negative number or value other than a number, the component fallbacks to its default value.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 1\n\t\t * @public\n\t\t */\n\t\tstep: {\n\t\t\ttype: Float,\n\t\t\tdefaultValue: 1,\n\t\t},\n\t\t/**\n\t\t * Displays a label with a value on every N-th step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step and tickmarks properties must be enabled.\n\t\t * Example - if the step value is set to 2 and the label interval is also specified to 2 - then every second\n\t\t * tickmark will be labelled, which means every 4th value number.\n\t\t *\n\t\t * @type {Integer}\n\t\t * @defaultvalue 0\n\t\t * @public\n\t\t */\n\t\tlabelInterval: {\n\t\t\ttype: Integer,\n\t\t\tdefaultValue: 0,\n\t\t},\n\t\t/**\n\t\t * Enables tick marks visualization for each step.\n\t\t * <br><br>\n\t\t * <b>Note:</b> The step must be a positive number.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Enables handle tooltip displaying the current value.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tshowTooltip: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * Defines whether the slider is in disabled state.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @defaultvalue false\n\t\t * @public\n\t\t */\n\t\tdisabled: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t/**\n\t\t * @private\n\t\t */\n\t\t_tooltipVisibility: {\n\t\t\ttype: String,\n\t\t\tdefaultValue: \"hidden\",\n\t\t},\n\t\t_labelsOverlapping: {\n\t\t\ttype: Boolean,\n\t\t},\n\t\t_hiddenTickmarks: {\n\t\t\ttype: Boolean,\n\t\t},\n\t},\n\tevents: /** @lends sap.ui.webcomponents.main.SliderBase.prototype */ {\n\t\t/**\n\t\t * Fired when the value changes and the user has finished interacting with the slider.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tchange: {},\n\t\t/**\n\t\t * Fired when the value changes due to user interaction that is not yet finished - during mouse/touch dragging.\n\t\t *\n\t\t * @event\n\t\t * @public\n\t\t*/\n\t\tinput: {},\n\t},\n};\n\n/**\n * @class\n *\n * <h3 class=\"comment-api-title\">Overview</h3>\n *\n *\n * @constructor\n * @author SAP SE\n * @alias sap.ui.webcomponents.main.SliderBase\n * @extends sap.ui.webcomponents.base.UI5Element\n * @tagname ui5-slider\n * @public\n */\nclass SliderBase extends UI5Element {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._resizeHandler = this._handleResize.bind(this);\n\t\tthis._moveHandler = this._handleMove.bind(this);\n\t\tthis._upHandler = this._handleUp.bind(this);\n\n\t\tthis._stateStorage = {\n\t\t\tstep: null,\n\t\t\tmin: null,\n\t\t\tmax: null,\n\t\t\tlabelInterval: null,\n\t\t};\n\t}\n\n\tstatic get metadata() {\n\t\treturn metadata;\n\t}\n\n\tstatic get render() {\n\t\treturn litRender;\n\t}\n\n\tstatic get styles() {\n\t\treturn styles;\n\t}\n\n\tstatic get TICKMARK_COLOR_MAP() {\n\t\treturn {\n\t\t\tsap_fiori_3: \"#89919a\",\n\t\t\tsap_fiori_3_dark: \"#89919a\",\n\t\t\tsap_fiori_3_hcw: \"#000000\",\n\t\t\tsap_fiori_3_hcb: \"#ffffff\",\n\t\t\tsap_belize: \"#bfbfbf\",\n\t\t\tsap_belize_hcw: \"#000000\",\n\t\t\tsap_belize_hcb: \"#ffffff\",\n\t\t};\n\t}\n\n\tstatic get UP_EVENTS() {\n\t\treturn [\"mouseup\", \"touchend\"];\n\t}\n\n\tstatic get MOVE_EVENT_MAP() {\n\t\treturn {\n\t\t\tmousedown: \"mousemove\",\n\t\t\ttouchstart: \"touchmove\",\n\t\t};\n\t}\n\n\tstatic get MIN_SPACE_BETWEEN_TICKMARKS() {\n\t\treturn 8;\n\t}\n\n\tget classes() {\n\t\treturn {\n\t\t\tlabelContainer: {\n\t\t\t\t\"ui5-slider-hidden-labels\": this._labelsOverlapping,\n\t\t\t},\n\t\t};\n\t}\n\n\tonEnterDOM() {\n\t\tResizeHandler.register(this, this._resizeHandler);\n\t}\n\n\tonExitDOM() {\n\t\tResizeHandler.deregister(this, this._handleResize);\n\t}\n\n\tonAfterRendering() {\n\t\t// Only call if the resize is triggered by a state changes other than\n\t\t// the ones that occured on the previous resize and those caused by user interaction.\n\t\tif (this.notResized) {\n\t\t\tthis._resizeHandler();\n\t\t}\n\t}\n\n\t_ontouchstart(event) {\n\t\tthis._onmousedown(event);\n\t}\n\n\t/** Shows the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseover(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"visible\";\n\t\t}\n\t}\n\n\t/**\n\t * Hides the tooltip(s) if the <code>showTooltip</code> property is set to true\n\t *\n\t * @private\n\t */\n\t_onmouseout(event) {\n\t\tif (this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"hidden\";\n\t\t}\n\t}\n\n\t/**\n\t * Handle the responsiveness of the Slider's UI elements when resizing\n\t *\n\t * @private\n\t */\n\t_handleResize() {\n\t\tif (!this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Mark resizing to avoid unneccessary calls to that function after rendering\n\t\tthis.notResized = false;\n\n\t\t// Convert the string represented calculation expression to a normal one\n\t\t// Check the distance  in pixels exist between every tickmark\n\t\tconst spaceBetweenTickmarks = this._spaceBetweenTickmarks();\n\n\t\t// If the pixels between the tickmarks are less than 8 only the first and the last one should be visible\n\t\t// In such case the labels must correspond to the tickmarks, only the first and the last one should exist.\n\t\tif (spaceBetweenTickmarks < SliderBase.MIN_SPACE_BETWEEN_TICKMARKS) {\n\t\t\tthis._hiddenTickmarks = true;\n\t\t\tthis._labelsOverlapping = true;\n\t\t} else {\n\t\t\tthis._hiddenTickmarks = false;\n\t\t}\n\n\t\tif (this.labelInterval <= 0 || this._hiddenTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\n\t\t// Check if there are any overlapping labels.\n\t\t// If so - only the first and the last one should be visible\n\t\tconst labelItems = this.shadowRoot.querySelectorAll(\".ui5-slider-labels li\");\n\t\tthis._labelsOverlapping = [...labelItems].some(label => label.scrollWidth > label.clientWidth);\n\t}\n\n\t/**\n\t * Called when the user starts interacting with the slider.\n\t * After a down event on the slider root, listen for move events on window, so the slider value\n\t * is updated even if the user drags the pointer outside the slider root.\n\t *\n\t * @protected\n\t */\n\thandleDownBase(event) {\n\t\tconst min = this._effectiveMin;\n\t\tconst max = this._effectiveMax;\n\t\tconst domRect = this.getBoundingClientRect();\n\t\tconst directionStart = this.directionStart;\n\t\tconst step = this._effectiveStep;\n\t\tconst newValue = SliderBase.getValueFromInteraction(event, step, min, max, domRect, directionStart);\n\n\t\tif (isPhone() && this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"visible\";\n\t\t}\n\n\t\t// Mark start of a user interaction\n\t\tthis._isUserInteraction = true;\n\t\t// Only allow one type of move event to be listened to (the first one registered after the down event)\n\t\tthis._moveEventType = !this._moveEventType ? SliderBase.MOVE_EVENT_MAP[event.type] : this._moveEventType;\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.addEventListener(upEventType, this._upHandler));\n\t\twindow.addEventListener(this._moveEventType, this._moveHandler);\n\n\t\treturn newValue;\n\t}\n\n\t/**\n\t * Called when the user finish interacting with the slider\n\t * Fires an <code>change</code> event indicating a final value change, after user interaction is finished.\n\t *\n\t * @protected\n\t */\n\thandleUpBase(valueType) {\n\t\tif (isPhone() && this.showTooltip) {\n\t\t\tthis._tooltipVisibility = \"hidden\";\n\t\t}\n\n\t\tSliderBase.UP_EVENTS.forEach(upEventType => window.removeEventListener(upEventType, this._upHandler));\n\t\twindow.removeEventListener(this._moveEventType, this._moveHandler);\n\n\t\tthis._moveEventType = null;\n\t\tthis._isUserInteraction = false;\n\t}\n\n\t/**\n\t * Updates value property of the component that has been changed due to a user action.\n\t * Fires an <code>input</code> event indicating a value change via interaction that is not yet finished.\n\t *\n\t * @protected\n\t */\n\tupdateValue(valueType, value) {\n\t\tthis[valueType] = value;\n\t\tthis.storePropertyState(valueType);\n\t\tif (this._isUserInteraction) {\n\t\t\tthis.fireEvent(\"input\");\n\t\t}\n\t}\n\n\t/**\n\t * Locks the given value between min and max boundaries based on slider properties\n\t *\n\t * @protected\n\t */\n\tstatic clipValue(value, min, max) {\n\t\tvalue = Math.min(Math.max(value, min), max);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Sets the slider value from an event\n\t *\n\t * @protected\n\t */\n\tstatic getValueFromInteraction(event, stepSize, min, max, boundingClientRect, directionStart) {\n\t\tconst pageX = this.getPageXValueFromEvent(event);\n\t\tconst value = this.computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart);\n\t\tconst steppedValue = this.getSteppedValue(value, stepSize, min);\n\n\t\treturn this.clipValue(steppedValue, min, max);\n\t}\n\n\t/**\n\t * \"Stepify\" the raw value - calculate the new value depending on the specified step property\n\t *\n\t * @protected\n\t */\n\tstatic getSteppedValue(value, stepSize, min) {\n\t\tconst stepModuloValue = Math.abs((value - min) % stepSize);\n\n\t\tif (stepSize === 0 || stepModuloValue === 0) {\n\t\t\treturn value;\n\t\t}\n\n\t\t// Clip (snap) the new value to the nearest step\n\t\tvalue = (stepModuloValue * 2 >= stepSize) ? (value + stepSize) - stepModuloValue : value - stepModuloValue;\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(stepSize);\n\t\treturn value.toFixed(stepPrecision);\n\t}\n\n\t/**\n\t * Gets pageX value from event on user interaction with the Slider\n\t *\n\t * @protected\n\t */\n\tstatic getPageXValueFromEvent(event) {\n\t\tif (event.targetTouches && event.targetTouches.length > 0) {\n\t\t\treturn event.targetTouches[0].pageX;\n\t\t}\n\n\t\treturn event.pageX;\n\t}\n\n\t/**\n\t * Computes the new value (in %) from the pageX position of the cursor.\n\t * Returns the value rounded to a precision of at most 2 digits after decimal point.\n\t *\n\t * @protected\n\t */\n\tstatic computedValueFromPageX(pageX, min, max, boundingClientRect, directionStart) {\n\t\t// Determine pageX position relative to the Slider DOM\n\t\tconst xRelativePosition = directionStart === \"left\" ? pageX - boundingClientRect[directionStart] : boundingClientRect[directionStart] - pageX;\n\t\t// Calculate the percentage complete (the \"progress\")\n\t\tconst percentageComplete = xRelativePosition / boundingClientRect.width;\n\t\t// Fit (map) the complete percentage between the min/max value range\n\t\treturn min + percentageComplete * (max - min);\n\t}\n\n\t/**\n\t * Calculates the precision (decimal places) of a number, returns 0 if integer\n\t * Handles scientific notation cases.\n\t * @private\n\t */\n\tstatic _getDecimalPrecisionOfNumber(value) {\n\t\tif (Number.isInteger(value)) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst match = (String(value)).match(/(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/);\n\t\treturn Math.max(0, (match[1] ? match[1].length : 0) - (match[2] ? Number(match[2]) : 0));\n\t}\n\n\t/**\n\t * Normalize current properties, update the previously stored state.\n\t *\n\t * @protected\n\t */\n\tsyncUIAndState(...values) {\n\t\t// Validate step and update the stored state for the step property.\n\t\tif (this.isPropertyUpdated(\"step\")) {\n\t\t\tthis._validateStep(this.step);\n\t\t\tthis.storePropertyState(\"step\");\n\t\t}\n\n\t\t// Recalculate the tickmarks and labels and update the stored state.\n\t\tif (this.isPropertyUpdated(\"min\", \"max\", ...values)) {\n\t\t\tthis.storePropertyState(\"min\", \"max\");\n\n\t\t\t// Here the value props are changed programatically (not by user interaction)\n\t\t\t// and it won't be \"stepified\" (rounded to the nearest step). 'Clip' them within\n\t\t\t// min and max bounderies and update the previous state reference.\n\t\t\tvalues.forEach(valueType => {\n\t\t\t\tconst normalizedValue = SliderBase.clipValue(this[valueType], this._effectiveMin, this._effectiveMax);\n\t\t\t\tthis.updateValue(valueType, normalizedValue);\n\t\t\t\tthis.storePropertyState(valueType);\n\t\t\t});\n\t\t}\n\n\t\t// Labels must be updated if any of the min/max/step/labelInterval props are changed\n\t\tif (this.labelInterval && this.showTickmarks) {\n\t\t\tthis._createLabels();\n\t\t}\n\n\t\t// Update the stored state for the labelInterval, if changed\n\t\tif (this.isPropertyUpdated(\"labelInterval\")) {\n\t\t\tthis.storePropertyState(\"labelInterval\");\n\t\t}\n\t}\n\n\t/**\n\t * In order to always keep the visual UI representation and the internal\n\t * state in sync, the component has a 'state storage' that is updated when the\n\t * current state is changed due to a user action.\n\t *\n\t * Check if the previously saved state is outdated. That would mean\n\t * a property has been changed programatically because the previous state\n\t * is always updated in the interaction handlers.\n\t *\n\t * Will return true if any of the properties is not equal to its previously\n\t * stored value.\n\t *\n\t * @protected\n\t */\n\tisCurrentStateOutdated() {\n\t\treturn Object.entries(this._stateStorage).some(([propName, propValue]) => this[propName] !== propValue);\n\t}\n\n\t/**\n\t * Returns the last stored value of a property\n\t *\n\t * @protected\n\t */\n\tgetStoredPropertyState(property) {\n\t\treturn this._stateStorage[property];\n\t}\n\n\t/**\n\t * Check if one or more properties have been updated compared to their last\n\t * saved values in the state storage.\n\t *\n\t * @protected\n\t */\n\tisPropertyUpdated(...properties) {\n\t\treturn properties.some(prop => this.getStoredPropertyState(prop) !== this[prop]);\n\t}\n\n\t/**\n\t * Updates the previously saved in the _stateStorage values of one or more properties.\n\t *\n\t * @protected\n\t */\n\tstorePropertyState(...props) {\n\t\tprops.forEach(property => {\n\t\t\tthis._stateStorage[property] = this[property];\n\t\t});\n\t}\n\n\t/**\n\t * Returns the start side of a direction - left for LTR, right for RTL\n\t */\n\tget directionStart() {\n\t\treturn this.effectiveDir === \"rtl\" ? \"right\" : \"left\";\n\t}\n\n\t/**\n\t * Calculates and draws the tickmarks with a CSS gradient style\n\t *\n\t * @private\n\t */\n\tget _tickmarks() {\n\t\tif (!this.showTickmarks || !this._effectiveStep) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (this._hiddenTickmarks) {\n\t\t\treturn `linear-gradient(to right, currentColor 1px, transparent 0) 0 center / calc(100% - 1px) 100% repeat-x`;\n\t\t}\n\n\t\t// Convert number values to strings to let the CSS do calculations better\n\t\t// rounding/subpixel behavior\" and the most precise tickmarks distribution\n\t\tconst maxStr = String(this._effectiveMax);\n\t\tconst minStr = String(this._effectiveMin);\n\t\tconst stepStr = String(this._effectiveStep);\n\t\tconst tickmarkWidth = \"1px\";\n\n\t\t// There is a CSS bug with the 'currentcolor' value of a CSS gradient that does not\n\t\t// respect the variable for more than one theme. It has to be set here for now.\n\t\tconst currentTheme = getTheme();\n\t\tconst currentColor = SliderBase.TICKMARK_COLOR_MAP[currentTheme];\n\n\t\tthis._tickmarksAmount = `${maxStr - minStr} / ${stepStr}`;\n\t\tthis._hiddenTickmarks = false;\n\n\t\t// Transparent CSS gradient background\n\t\tconst tickmarksGradientBase = `linear-gradient(to right, ${currentColor} ${tickmarkWidth}, transparent 0) `;\n\n\t\t// Draw the tickmarks as a patern over the gradient background\n\t\tconst tickmarksGradientdPattern = `0 center / calc((100% - ${tickmarkWidth}) / (${this._tickmarksAmount})) 100% repeat-x`;\n\n\t\t// Combine to get the complete CSS background gradient property value\n\t\treturn `${tickmarksGradientBase + tickmarksGradientdPattern}`;\n\t}\n\n\t/**\n\t * Calculates the labels amout, width and text and creates them\n\t *\n\t * @private\n\t */\n\t_createLabels() {\n\t\tif (!this.labelInterval || !this.showTickmarks) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst labelInterval = this.labelInterval;\n\t\tconst step = this._effectiveStep;\n\t\tconst newNumberOfLabels = (this._effectiveMax - this._effectiveMin) / (step * labelInterval);\n\n\t\t// If the required labels are already rendered\n\t\tif (newNumberOfLabels === this._oldNumberOfLabels) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._oldNumberOfLabels = newNumberOfLabels;\n\t\tthis._labelWidth = 100 / newNumberOfLabels;\n\t\tthis._labelValues = [];\n\n\t\t// If the step value is not a round number get its precision\n\t\tconst stepPrecision = SliderBase._getDecimalPrecisionOfNumber(step);\n\n\t\t// numberOfLabels below can be float so that the \"distance betweenlabels labels\"\n\t\t// calculation to be precize (exactly the same as the distance between the tickmarks).\n\t\t// That's ok as the loop stop condition is set to an integer, so it will practically\n\t\t// \"floor\" the number of labels anyway.\n\t\tfor (let i = 0; i <= newNumberOfLabels; i++) {\n\t\t\t// Format the label numbers with the same decimal precision as the value of the step property\n\t\t\tconst labelItemNumber = ((i * step * labelInterval) + this._effectiveMin).toFixed(stepPrecision);\n\t\t\tthis._labelValues.push(labelItemNumber);\n\t\t}\n\t}\n\n\tget _labels() {\n\t\treturn this._labelValues || [];\n\t}\n\n\t/**\n\t * Calculates space between tickmarks\n\t *\n\t * @private\n\t */\n\t_spaceBetweenTickmarks() {\n\t\tconst tickmarksAmountStrCalc = this._tickmarksAmount.split(\"/\");\n\t\tconst tickmarksAmount = tickmarksAmountStrCalc[0] / tickmarksAmountStrCalc[1];\n\n\t\treturn this.getBoundingClientRect().width / tickmarksAmount;\n\t}\n\n\t/**\n\t * Notify in case of a invalid step value type\n\t *\n\t * @private\n\t */\n\t_validateStep(step) {\n\t\tif (step === 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number\"); // eslint-disable-line\n\t\t}\n\n\t\tif (step < 0) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. The provided negative number has been converted to its positve equivalent\"); // eslint-disable-line\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tconsole.warn(\"The 'step' property must be a positive float number. It has been set to its default value of 1\"); // eslint-disable-line\n\t\t}\n\t}\n\n\t/**\n\t * Normalizes a new <code>step</code> property value.\n\t * If tickmarks are enabled recreates them according to it.\n\t *\n\t * @private\n\t */\n\tget _effectiveStep() {\n\t\tlet step = this.step;\n\n\t\tif (step < 0) {\n\t\t\tstep = Math.abs(step);\n\t\t}\n\n\t\tif (typeof step !== \"number\" || Number.isNaN(step)) {\n\t\t\tstep = 1;\n\t\t}\n\n\t\treturn step;\n\t}\n\n\tget _effectiveMin() {\n\t\treturn Math.min(this.min, this.max);\n\t}\n\n\tget _effectiveMax() {\n\t\treturn Math.max(this.min, this.max);\n\t}\n}\n\nexport default SliderBase;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}