{"ast":null,"code":"const findClosingParenthesisPos = (str, openingParenthesisPos) => {\n  let opened = 1;\n  for (let pos = openingParenthesisPos + 1; pos < str.length; pos++) {\n    const char = str.charAt(pos);\n    if (char === \"(\") {\n      opened++;\n    } else if (char === \")\") {\n      opened--;\n    }\n    if (opened === 0) {\n      return pos;\n    }\n  }\n};\nconst replaceSelector = (str, selector, selectorStartPos, replacement) => {\n  const charAfterSelectorPos = selectorStartPos + selector.length;\n  const charAfterSelector = str.charAt(charAfterSelectorPos);\n  const upToSelector = str.substring(0, selectorStartPos) + replacement;\n  if (charAfterSelector === \"(\") {\n    const closingParenthesisPos = findClosingParenthesisPos(str, charAfterSelectorPos);\n    return upToSelector + str.substring(charAfterSelectorPos + 1, closingParenthesisPos) + str.substring(closingParenthesisPos + 1);\n  }\n  return upToSelector + str.substring(charAfterSelectorPos);\n};\n\n/**\n * :host => ui5-button\n * :host([expr]) => ui5-button[expr]\n * ::slotted(expr) => expr\n * @param str - source string\n * @param selector - :host or ::slotted\n * @param replacement - normally tag name\n * @returns {*}\n */\nconst replaceSelectors = (str, selector, replacement) => {\n  let selectorStartPos = str.indexOf(selector);\n  while (selectorStartPos !== -1) {\n    str = replaceSelector(str, selector, selectorStartPos, replacement);\n    selectorStartPos = str.indexOf(selector);\n  }\n  return str;\n};\nconst adaptLinePart = (line, tag, pureTag) => {\n  line = line.trim();\n  line = replaceSelectors(line, \"::slotted\", ``); // first remove all ::slotted() occurrences\n\n  // Host selector - replace it\n  if (line.startsWith(\":host\")) {\n    return replaceSelector(line, \":host\", 0, tag);\n  }\n\n  // Leave out @keyframes and keyframe values (0%, 100%, etc...)\n  // csso shortens '100%' -> 'to', make sure to leave it untouched\n  if (line.match(/^[@0-9]/) || line === \"to\" || line === \"to{\") {\n    return line;\n  }\n\n  // IE specific selector (directly written with the tag, f.e. ui5-button {}) - keep it\n  if (line.match(new RegExp(`^${tag}[^a-zA-Z0-9-]`))) {\n    return line;\n  }\n\n  // IE specific selector (directly written with the tag attribute, f.e. [ui5-button] {}) - keep it\n  if (pureTag && line.startsWith(`[${pureTag}]`)) {\n    return line;\n  }\n\n  // No host and no tag in the beginning of the selector - prepend the tag\n  return `${tag} ${line}`;\n};\nconst adaptCSSForIE = (str, tag, pureTag) => {\n  str = str.replace(/\\n/g, ` `);\n  str = str.replace(/([{}])/g, `$1\\n`);\n  let result = ``;\n  const lines = str.split(`\\n`);\n  lines.forEach(line => {\n    const mustProcess = line.match(/{$/); // Only work on lines that end on {, otherwise just append to result\n    if (mustProcess) {\n      const lineParts = line.split(\",\");\n      const processedLineParts = lineParts.map(linePart => {\n        return adaptLinePart(linePart, tag, pureTag);\n      });\n      line = processedLineParts.join(\",\");\n    }\n    result = `${result}${line}`;\n  });\n  return result;\n};\nexport default adaptCSSForIE;","map":{"version":3,"names":["findClosingParenthesisPos","str","openingParenthesisPos","opened","pos","length","char","charAt","replaceSelector","selector","selectorStartPos","replacement","charAfterSelectorPos","charAfterSelector","upToSelector","substring","closingParenthesisPos","replaceSelectors","indexOf","adaptLinePart","line","tag","pureTag","trim","startsWith","match","RegExp","adaptCSSForIE","replace","result","lines","split","forEach","mustProcess","lineParts","processedLineParts","map","linePart","join"],"sources":["/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/@ui5/webcomponents-base/dist/theming/adaptCSSForIE.js"],"sourcesContent":["const findClosingParenthesisPos = (str, openingParenthesisPos) => {\n\tlet opened = 1;\n\tfor (let pos = openingParenthesisPos + 1; pos < str.length; pos++) {\n\t\tconst char = str.charAt(pos);\n\t\tif (char === \"(\") {\n\t\t\topened++;\n\t\t} else if (char === \")\") {\n\t\t\topened--;\n\t\t}\n\t\tif (opened === 0) {\n\t\t\treturn pos;\n\t\t}\n\t}\n};\n\nconst replaceSelector = (str, selector, selectorStartPos, replacement) => {\n\tconst charAfterSelectorPos = selectorStartPos + selector.length;\n\tconst charAfterSelector = str.charAt(charAfterSelectorPos);\n\n\tconst upToSelector = str.substring(0, selectorStartPos) + replacement;\n\tif (charAfterSelector === \"(\") {\n\t\tconst closingParenthesisPos = findClosingParenthesisPos(str, charAfterSelectorPos);\n\t\treturn upToSelector + str.substring(charAfterSelectorPos + 1, closingParenthesisPos) + str.substring(closingParenthesisPos + 1);\n\t}\n\n\treturn upToSelector + str.substring(charAfterSelectorPos);\n};\n\n/**\n * :host => ui5-button\n * :host([expr]) => ui5-button[expr]\n * ::slotted(expr) => expr\n * @param str - source string\n * @param selector - :host or ::slotted\n * @param replacement - normally tag name\n * @returns {*}\n */\nconst replaceSelectors = (str, selector, replacement) => {\n\tlet selectorStartPos = str.indexOf(selector);\n\twhile (selectorStartPos !== -1) {\n\t\tstr = replaceSelector(str, selector, selectorStartPos, replacement);\n\t\tselectorStartPos = str.indexOf(selector);\n\t}\n\treturn str;\n};\n\nconst adaptLinePart = (line, tag, pureTag) => {\n\tline = line.trim();\n\tline = replaceSelectors(line, \"::slotted\", ``); // first remove all ::slotted() occurrences\n\n\t// Host selector - replace it\n\tif (line.startsWith(\":host\")) {\n\t\treturn replaceSelector(line, \":host\", 0, tag);\n\t}\n\n\t// Leave out @keyframes and keyframe values (0%, 100%, etc...)\n\t// csso shortens '100%' -> 'to', make sure to leave it untouched\n\tif (line.match(/^[@0-9]/) || line === \"to\" || line === \"to{\") {\n\t\treturn line;\n\t}\n\n\t// IE specific selector (directly written with the tag, f.e. ui5-button {}) - keep it\n\tif (line.match(new RegExp(`^${tag}[^a-zA-Z0-9-]`))) {\n\t\treturn line;\n\t}\n\n\t// IE specific selector (directly written with the tag attribute, f.e. [ui5-button] {}) - keep it\n\tif (pureTag && line.startsWith(`[${pureTag}]`)) {\n\t\treturn line;\n\t}\n\n\t// No host and no tag in the beginning of the selector - prepend the tag\n\treturn `${tag} ${line}`;\n};\n\nconst adaptCSSForIE = (str, tag, pureTag) => {\n\tstr = str.replace(/\\n/g, ` `);\n\tstr = str.replace(/([{}])/g, `$1\\n`);\n\tlet result = ``;\n\tconst lines = str.split(`\\n`);\n\tlines.forEach(line => {\n\t\tconst mustProcess = line.match(/{$/); // Only work on lines that end on {, otherwise just append to result\n\t\tif (mustProcess) {\n\t\t\tconst lineParts = line.split(\",\");\n\t\t\tconst processedLineParts = lineParts.map(linePart => {\n\t\t\t\treturn adaptLinePart(linePart, tag, pureTag);\n\t\t\t});\n\t\t\tline = processedLineParts.join(\",\");\n\t\t}\n\t\tresult = `${result}${line}`;\n\t});\n\treturn result;\n};\n\nexport default adaptCSSForIE;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}