{"ast":null,"code":"import DataType from \"./types/DataType.js\";\nimport isDescendantOf from \"./util/isDescendantOf.js\";\nimport { camelToKebabCase } from \"./util/StringHelper.js\";\nimport isSlot from \"./util/isSlot.js\";\nimport { getEffectiveScopingSuffixForTag } from \"./CustomElementsScope.js\";\n\n/**\n *\n * @class\n * @public\n */\nclass UI5ElementMetadata {\n  constructor(metadata) {\n    this.metadata = metadata;\n  }\n\n  /**\n   * Only intended for use by UI5Element.js\n   * @protected\n   */\n  static validatePropertyValue(value, propData) {\n    const isMultiple = propData.multiple;\n    if (isMultiple) {\n      return value.map(propValue => validateSingleProperty(propValue, propData));\n    }\n    return validateSingleProperty(value, propData);\n  }\n\n  /**\n   * Only intended for use by UI5Element.js\n   * @protected\n   */\n  static validateSlotValue(value, slotData) {\n    return validateSingleSlot(value, slotData);\n  }\n\n  /**\n   * Returns the tag of the UI5 Element without the scope\n   * @public\n   */\n  getPureTag() {\n    return this.metadata.tag;\n  }\n\n  /**\n   * Returns the tag of the UI5 Element\n   * @public\n   */\n  getTag() {\n    const pureTag = this.metadata.tag;\n    const suffix = getEffectiveScopingSuffixForTag(pureTag);\n    if (!suffix) {\n      return pureTag;\n    }\n    return `${pureTag}-${suffix}`;\n  }\n\n  /**\n   * Used to get the tag we need to register for backwards compatibility\n   * @public\n   */\n  getAltTag() {\n    const pureAltTag = this.metadata.altTag;\n    if (!pureAltTag) {\n      return;\n    }\n    const suffix = getEffectiveScopingSuffixForTag(pureAltTag);\n    if (!suffix) {\n      return pureAltTag;\n    }\n    return `${pureAltTag}-${suffix}`;\n  }\n\n  /**\n   * Determines whether a property should have an attribute counterpart\n   * @public\n   * @param propName\n   * @returns {boolean}\n   */\n  hasAttribute(propName) {\n    const propData = this.getProperties()[propName];\n    return propData.type !== Object && !propData.noAttribute;\n  }\n\n  /**\n   * Returns an array with the properties of the UI5 Element (in camelCase)\n   * @public\n   * @returns {string[]}\n   */\n  getPropertiesList() {\n    return Object.keys(this.getProperties());\n  }\n\n  /**\n   * Returns an array with the attributes of the UI5 Element (in kebab-case)\n   * @public\n   * @returns {string[]}\n   */\n  getAttributesList() {\n    return this.getPropertiesList().filter(this.hasAttribute, this).map(camelToKebabCase);\n  }\n\n  /**\n   * Returns an object with key-value pairs of slots and their metadata definitions\n   * @public\n   */\n  getSlots() {\n    return this.metadata.slots || {};\n  }\n\n  /**\n   * Determines whether this UI5 Element has a default slot of type Node, therefore can slot text\n   * @returns {boolean}\n   */\n  canSlotText() {\n    const defaultSlot = this.getSlots().default;\n    return defaultSlot && defaultSlot.type === Node;\n  }\n\n  /**\n   * Determines whether this UI5 Element supports any slots\n   * @public\n   */\n  hasSlots() {\n    return !!Object.entries(this.getSlots()).length;\n  }\n\n  /**\n   * Determines whether this UI5 Element supports any slots with \"individualSlots: true\"\n   * @public\n   */\n  hasIndividualSlots() {\n    return this.slotsAreManaged() && Object.entries(this.getSlots()).some(([_slotName, slotData]) => slotData.individualSlots);\n  }\n\n  /**\n   * Determines whether this UI5 Element needs to invalidate if children are added/removed/changed\n   * @public\n   */\n  slotsAreManaged() {\n    return !!this.metadata.managedSlots;\n  }\n\n  /**\n   * Returns an object with key-value pairs of properties and their metadata definitions\n   * @public\n   */\n  getProperties() {\n    return this.metadata.properties || {};\n  }\n\n  /**\n   * Returns an object with key-value pairs of events and their metadata definitions\n   * @public\n   */\n  getEvents() {\n    return this.metadata.events || {};\n  }\n\n  /**\n   * Determines whether this UI5 Element has any translatable texts (needs to be invalidated upon language change)\n   * @returns {boolean}\n   */\n  isLanguageAware() {\n    return !!this.metadata.languageAware;\n  }\n\n  /**\n   * Matches a changed entity (property/slot) with the given name against the \"invalidateOnChildChange\" configuration\n   * and determines whether this should cause and invalidation\n   *\n   * @param slotName the name of the slot in which a child was changed\n   * @param type the type of change in the child: \"property\" or \"slot\"\n   * @param name the name of the property/slot that changed\n   * @returns {boolean}\n   */\n  shouldInvalidateOnChildChange(slotName, type, name) {\n    const config = this.getSlots()[slotName].invalidateOnChildChange;\n\n    // invalidateOnChildChange was not set in the slot metadata - by default child changes do not affect the component\n    if (config === undefined) {\n      return false;\n    }\n\n    // The simple format was used: invalidateOnChildChange: true/false;\n    if (typeof config === \"boolean\") {\n      return config;\n    }\n\n    // The complex format was used: invalidateOnChildChange: { properties, slots }\n    if (typeof config === \"object\") {\n      // A property was changed\n      if (type === \"property\") {\n        // The config object does not have a properties field\n        if (config.properties === undefined) {\n          return false;\n        }\n\n        // The config object has the short format: properties: true/false\n        if (typeof config.properties === \"boolean\") {\n          return config.properties;\n        }\n\n        // The config object has the complex format: properties: [...]\n        if (Array.isArray(config.properties)) {\n          return config.properties.includes(name);\n        }\n        throw new Error(\"Wrong format for invalidateOnChildChange.properties: boolean or array is expected\");\n      }\n\n      // A slot was changed\n      if (type === \"slot\") {\n        // The config object does not have a slots field\n        if (config.slots === undefined) {\n          return false;\n        }\n\n        // The config object has the short format: slots: true/false\n        if (typeof config.slots === \"boolean\") {\n          return config.slots;\n        }\n\n        // The config object has the complex format: slots: [...]\n        if (Array.isArray(config.slots)) {\n          return config.slots.includes(name);\n        }\n        throw new Error(\"Wrong format for invalidateOnChildChange.slots: boolean or array is expected\");\n      }\n    }\n    throw new Error(\"Wrong format for invalidateOnChildChange: boolean or object is expected\");\n  }\n}\nconst validateSingleProperty = (value, propData) => {\n  const propertyType = propData.type;\n  if (propertyType === Boolean) {\n    return typeof value === \"boolean\" ? value : false;\n  }\n  if (propertyType === String) {\n    return typeof value === \"string\" || typeof value === \"undefined\" || value === null ? value : value.toString();\n  }\n  if (propertyType === Object) {\n    return typeof value === \"object\" ? value : propData.defaultValue;\n  }\n  if (isDescendantOf(propertyType, DataType)) {\n    return propertyType.isValid(value) ? value : propData.defaultValue;\n  }\n};\nconst validateSingleSlot = (value, slotData) => {\n  if (value === null) {\n    return value;\n  }\n  const getSlottedNodes = el => {\n    if (isSlot(el)) {\n      return el.assignedNodes({\n        flatten: true\n      }).filter(item => item instanceof HTMLElement);\n    }\n    return [el];\n  };\n  const slottedNodes = getSlottedNodes(value);\n  slottedNodes.forEach(el => {\n    if (!(el instanceof slotData.type)) {\n      throw new Error(`${el} is not of type ${slotData.type}`);\n    }\n  });\n  return value;\n};\nexport default UI5ElementMetadata;","map":{"version":3,"names":["DataType","isDescendantOf","camelToKebabCase","isSlot","getEffectiveScopingSuffixForTag","UI5ElementMetadata","constructor","metadata","validatePropertyValue","value","propData","isMultiple","multiple","map","propValue","validateSingleProperty","validateSlotValue","slotData","validateSingleSlot","getPureTag","tag","getTag","pureTag","suffix","getAltTag","pureAltTag","altTag","hasAttribute","propName","getProperties","type","Object","noAttribute","getPropertiesList","keys","getAttributesList","filter","getSlots","slots","canSlotText","defaultSlot","default","Node","hasSlots","entries","length","hasIndividualSlots","slotsAreManaged","some","_slotName","individualSlots","managedSlots","properties","getEvents","events","isLanguageAware","languageAware","shouldInvalidateOnChildChange","slotName","name","config","invalidateOnChildChange","undefined","Array","isArray","includes","Error","propertyType","Boolean","String","toString","defaultValue","isValid","getSlottedNodes","el","assignedNodes","flatten","item","HTMLElement","slottedNodes","forEach"],"sources":["/home/paris/projekty/haergi/feng/workspace/recipe-sharing-app/frontend/node_modules/@ui5/webcomponents-base/dist/UI5ElementMetadata.js"],"sourcesContent":["import DataType from \"./types/DataType.js\";\nimport isDescendantOf from \"./util/isDescendantOf.js\";\nimport { camelToKebabCase } from \"./util/StringHelper.js\";\nimport isSlot from \"./util/isSlot.js\";\nimport { getEffectiveScopingSuffixForTag } from \"./CustomElementsScope.js\";\n\n/**\n *\n * @class\n * @public\n */\nclass UI5ElementMetadata {\n\tconstructor(metadata) {\n\t\tthis.metadata = metadata;\n\t}\n\n\t/**\n\t * Only intended for use by UI5Element.js\n\t * @protected\n\t */\n\tstatic validatePropertyValue(value, propData) {\n\t\tconst isMultiple = propData.multiple;\n\t\tif (isMultiple) {\n\t\t\treturn value.map(propValue => validateSingleProperty(propValue, propData));\n\t\t}\n\t\treturn validateSingleProperty(value, propData);\n\t}\n\n\t/**\n\t * Only intended for use by UI5Element.js\n\t * @protected\n\t */\n\tstatic validateSlotValue(value, slotData) {\n\t\treturn validateSingleSlot(value, slotData);\n\t}\n\n\t/**\n\t * Returns the tag of the UI5 Element without the scope\n\t * @public\n\t */\n\tgetPureTag() {\n\t\treturn this.metadata.tag;\n\t}\n\n\t/**\n\t * Returns the tag of the UI5 Element\n\t * @public\n\t */\n\tgetTag() {\n\t\tconst pureTag = this.metadata.tag;\n\t\tconst suffix = getEffectiveScopingSuffixForTag(pureTag);\n\t\tif (!suffix) {\n\t\t\treturn pureTag;\n\t\t}\n\n\t\treturn `${pureTag}-${suffix}`;\n\t}\n\n\t/**\n\t * Used to get the tag we need to register for backwards compatibility\n\t * @public\n\t */\n\tgetAltTag() {\n\t\tconst pureAltTag = this.metadata.altTag;\n\t\tif (!pureAltTag) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst suffix = getEffectiveScopingSuffixForTag(pureAltTag);\n\t\tif (!suffix) {\n\t\t\treturn pureAltTag;\n\t\t}\n\n\t\treturn `${pureAltTag}-${suffix}`;\n\t}\n\n\t/**\n\t * Determines whether a property should have an attribute counterpart\n\t * @public\n\t * @param propName\n\t * @returns {boolean}\n\t */\n\thasAttribute(propName) {\n\t\tconst propData = this.getProperties()[propName];\n\t\treturn propData.type !== Object && !propData.noAttribute;\n\t}\n\n\t/**\n\t * Returns an array with the properties of the UI5 Element (in camelCase)\n\t * @public\n\t * @returns {string[]}\n\t */\n\tgetPropertiesList() {\n\t\treturn Object.keys(this.getProperties());\n\t}\n\n\t/**\n\t * Returns an array with the attributes of the UI5 Element (in kebab-case)\n\t * @public\n\t * @returns {string[]}\n\t */\n\tgetAttributesList() {\n\t\treturn this.getPropertiesList().filter(this.hasAttribute, this).map(camelToKebabCase);\n\t}\n\n\t/**\n\t * Returns an object with key-value pairs of slots and their metadata definitions\n\t * @public\n\t */\n\tgetSlots() {\n\t\treturn this.metadata.slots || {};\n\t}\n\n\t/**\n\t * Determines whether this UI5 Element has a default slot of type Node, therefore can slot text\n\t * @returns {boolean}\n\t */\n\tcanSlotText() {\n\t\tconst defaultSlot = this.getSlots().default;\n\t\treturn defaultSlot && defaultSlot.type === Node;\n\t}\n\n\t/**\n\t * Determines whether this UI5 Element supports any slots\n\t * @public\n\t */\n\thasSlots() {\n\t\treturn !!Object.entries(this.getSlots()).length;\n\t}\n\n\t/**\n\t * Determines whether this UI5 Element supports any slots with \"individualSlots: true\"\n\t * @public\n\t */\n\thasIndividualSlots() {\n\t\treturn this.slotsAreManaged() && Object.entries(this.getSlots()).some(([_slotName, slotData]) => slotData.individualSlots);\n\t}\n\n\t/**\n\t * Determines whether this UI5 Element needs to invalidate if children are added/removed/changed\n\t * @public\n\t */\n\tslotsAreManaged() {\n\t\treturn !!this.metadata.managedSlots;\n\t}\n\n\t/**\n\t * Returns an object with key-value pairs of properties and their metadata definitions\n\t * @public\n\t */\n\tgetProperties() {\n\t\treturn this.metadata.properties || {};\n\t}\n\n\t/**\n\t * Returns an object with key-value pairs of events and their metadata definitions\n\t * @public\n\t */\n\tgetEvents() {\n\t\treturn this.metadata.events || {};\n\t}\n\n\t/**\n\t * Determines whether this UI5 Element has any translatable texts (needs to be invalidated upon language change)\n\t * @returns {boolean}\n\t */\n\tisLanguageAware() {\n\t\treturn !!this.metadata.languageAware;\n\t}\n\n\t/**\n\t * Matches a changed entity (property/slot) with the given name against the \"invalidateOnChildChange\" configuration\n\t * and determines whether this should cause and invalidation\n\t *\n\t * @param slotName the name of the slot in which a child was changed\n\t * @param type the type of change in the child: \"property\" or \"slot\"\n\t * @param name the name of the property/slot that changed\n\t * @returns {boolean}\n\t */\n\tshouldInvalidateOnChildChange(slotName, type, name) {\n\t\tconst config = this.getSlots()[slotName].invalidateOnChildChange;\n\n\t\t// invalidateOnChildChange was not set in the slot metadata - by default child changes do not affect the component\n\t\tif (config === undefined) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// The simple format was used: invalidateOnChildChange: true/false;\n\t\tif (typeof config === \"boolean\") {\n\t\t\treturn config;\n\t\t}\n\n\t\t// The complex format was used: invalidateOnChildChange: { properties, slots }\n\t\tif (typeof config === \"object\") {\n\t\t\t// A property was changed\n\t\t\tif (type === \"property\") {\n\t\t\t\t// The config object does not have a properties field\n\t\t\t\tif (config.properties === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The config object has the short format: properties: true/false\n\t\t\t\tif (typeof config.properties === \"boolean\") {\n\t\t\t\t\treturn config.properties;\n\t\t\t\t}\n\n\t\t\t\t// The config object has the complex format: properties: [...]\n\t\t\t\tif (Array.isArray(config.properties)) {\n\t\t\t\t\treturn config.properties.includes(name);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"Wrong format for invalidateOnChildChange.properties: boolean or array is expected\");\n\t\t\t}\n\n\t\t\t// A slot was changed\n\t\t\tif (type === \"slot\") {\n\t\t\t\t// The config object does not have a slots field\n\t\t\t\tif (config.slots === undefined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The config object has the short format: slots: true/false\n\t\t\t\tif (typeof config.slots === \"boolean\") {\n\t\t\t\t\treturn config.slots;\n\t\t\t\t}\n\n\t\t\t\t// The config object has the complex format: slots: [...]\n\t\t\t\tif (Array.isArray(config.slots)) {\n\t\t\t\t\treturn config.slots.includes(name);\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"Wrong format for invalidateOnChildChange.slots: boolean or array is expected\");\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(\"Wrong format for invalidateOnChildChange: boolean or object is expected\");\n\t}\n}\n\nconst validateSingleProperty = (value, propData) => {\n\tconst propertyType = propData.type;\n\n\tif (propertyType === Boolean) {\n\t\treturn typeof value === \"boolean\" ? value : false;\n\t}\n\tif (propertyType === String) {\n\t\treturn (typeof value === \"string\" || typeof value === \"undefined\" || value === null) ? value : value.toString();\n\t}\n\tif (propertyType === Object) {\n\t\treturn typeof value === \"object\" ? value : propData.defaultValue;\n\t}\n\tif (isDescendantOf(propertyType, DataType)) {\n\t\treturn propertyType.isValid(value) ? value : propData.defaultValue;\n\t}\n};\n\nconst validateSingleSlot = (value, slotData) => {\n\tif (value === null) {\n\t\treturn value;\n\t}\n\n\tconst getSlottedNodes = el => {\n\t\tif (isSlot(el)) {\n\t\t\treturn el.assignedNodes({ flatten: true }).filter(item => item instanceof HTMLElement);\n\t\t}\n\n\t\treturn [el];\n\t};\n\n\tconst slottedNodes = getSlottedNodes(value);\n\tslottedNodes.forEach(el => {\n\t\tif (!(el instanceof slotData.type)) {\n\t\t\tthrow new Error(`${el} is not of type ${slotData.type}`);\n\t\t}\n\t});\n\n\treturn value;\n};\n\nexport default UI5ElementMetadata;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}