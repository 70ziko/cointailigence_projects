import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { supportTouch, getOS, getSystem } from '@ui5/webcomponents-base/dist/Device';
export { getBrowser, getOS, getSystem, isAndroid, isChrome, isDesktop, isEdge, isFF, isIE, isMobile, isPhone, isSafari, isTablet, supportTouch } from '@ui5/webcomponents-base/dist/Device';
import EventProvider from '@ui5/webcomponents-base/dist/EventProvider';
import _createForOfIteratorHelper from '@babel/runtime/helpers/createForOfIteratorHelper';
import _defineProperty from '@babel/runtime/helpers/defineProperty';
import { Logger } from '@ui5/webcomponents-react-base/lib/Logger';

var supportPointerEvents = function supportPointerEvents() {
  return 'onpointerdown' in window;
};
var supportInputPlaceholder = function supportInputPlaceholder() {
  return 'placeholder' in document.createElement('input') && 'placeholder' in document.createElement('textarea');
};
var supportWebSocket = function supportWebSocket() {
  var isSupported = false;

  try {
    isSupported = 'WebSocket' in window && window.WebSocket.CLOSING === 2;
  } catch (e) {// do nothing
  }

  return isSupported;
};
var supportMatchMedia = function supportMatchMedia() {
  return 'matchMedia' in window;
};
var supportMatchMediaListener = function supportMatchMediaListener() {
  return !!(supportMatchMedia() && window.matchMedia('all and (max-width:0px)'));
};
var supportOrientation = function supportOrientation() {
  return 'DeviceOrientationEvent' in window;
};
var supportRetina = function supportRetina() {
  return window.retina || window.devicePixelRatio >= 2;
};

var getWindowSize = function getWindowSize() {
  return [window.innerWidth, window.innerHeight];
};
var changeRootCSSClass = function changeRootCSSClass(sClassName, bRemove, sPrefix) {
  var oRoot = document.documentElement;

  if (oRoot.className.length === 0) {
    if (!bRemove) {
      oRoot.className = sClassName;
    }
  } else {
    var aCurrentClasses = oRoot.className.split(' ');
    var sNewClasses = '';
    aCurrentClasses.forEach(function (currentClass) {
      // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
      if (sPrefix && currentClass.indexOf(sPrefix) !== 0 || !sPrefix && currentClass !== sClassName) {
        sNewClasses = "".concat(sNewClasses + currentClass, " ");
      }
    });

    if (!bRemove) {
      sNewClasses += sClassName;
    }

    oRoot.className = sNewClasses;
  }
};
var getQuery = function getQuery(from, to) {
  var unit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'px';
  var q = 'all';

  if (from > 0) {
    q = "".concat(q, " and (min-width:").concat(from).concat(unit, ")");
  }

  if (to > 0) {
    q = "".concat(q, " and (max-width:").concat(to).concat(unit, ")");
  }

  return q;
};
var convertToPx = function convertToPx(val, unit) {
  if (unit === 'em' || unit === 'rem') {
    var _window$getComputedSt;

    var s = (_window$getComputedSt = window.getComputedStyle) !== null && _window$getComputedSt !== void 0 ? _window$getComputedSt : function (element) {
      return element.currentStyle;
    };
    var x = s(document.documentElement).fontSize;
    var f = x && x.indexOf('px') >= 0 ? parseFloat(x) : 16;
    return val * f;
  }

  return val;
};
var matchLegacyBySize = function matchLegacyBySize(from, to, unit, size) {
  from = convertToPx(from, unit);
  to = convertToPx(to, unit);
  var width = size[0];
  var a = from < 0 || from <= width;
  var b = to < 0 || width <= to;
  return a && b;
};
var isLandscape = function isLandscape(bFromOrientationChange, orientation, bKeyboardOpen) {
  if (supportTouch() && supportOrientation() && getOS().android) {
    // if on screen keyboard is open and the call of this method is from orientation change listener,
    // reverse the last value. this is because when keyboard opens on android device, the height can be less
    // than the width even in portrait mode.
    if (bKeyboardOpen && bFromOrientationChange) {
      return !orientation.landscape;
    }

    if (bKeyboardOpen) {
      // when keyboard opens, the last orientation change value will be returned.
      return orientation.landscape;
    }
  } else if (supportMatchMedia() && supportOrientation()) {
    // most desktop browsers and windows phone/tablet which not support orientationchange
    return !!window.matchMedia('(orientation: landscape)').matches;
  } // otherwise compare the width and height of window


  var size = getWindowSize();
  return size[0] > size[1];
};

var MediaEventProvider = new EventProvider();

var _DEFAULT_RANGESETS;
var eventProvider = MediaEventProvider; // private helpers

var initializedQuerySets = {};

var refreshCSSClasses = function refreshCSSClasses(sSetName, sRangeName, bRemove) {
  var sClassPrefix = "sapUiMedia-".concat(sSetName, "-");
  changeRootCSSClass(sClassPrefix + sRangeName, bRemove, sClassPrefix);
};

var getRangeInfo = function getRangeInfo(sSetName, iRangeIdx) {
  var q = initializedQuerySets[sSetName].queries[iRangeIdx];
  var info = {
    from: q.from,
    unit: initializedQuerySets[sSetName].unit
  };

  if (q.to >= 0) {
    info.to = q.to;
  }

  if (initializedQuerySets[sSetName].names) {
    info.name = initializedQuerySets[sSetName].names[iRangeIdx];
  }

  return info;
};

var matches = function matches(from, to, unit) {
  var q = getQuery(from, to, unit);
  var mm = window.matchMedia(q); // FF returns null when running within an iframe with display:none

  return mm && mm.matches;
};

var checkQueries = function checkQueries(name, infoOnly) {
  var fnMatches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : matches;

  if (initializedQuerySets[name]) {
    var aQueries = initializedQuerySets[name].queries;
    var info = null;

    for (var i = 0, len = aQueries.length; i < len; i++) {
      var q = aQueries[i];

      if ((q !== initializedQuerySets[name].currentquery || infoOnly) && fnMatches(q.from, q.to, initializedQuerySets[name].unit)) {
        if (!infoOnly) {
          initializedQuerySets[name].currentquery = q;
        }

        if (!initializedQuerySets[name].noClasses && initializedQuerySets[name].names && !infoOnly) {
          refreshCSSClasses(name, initializedQuerySets[name].names[i]);
        }

        info = getRangeInfo(name, i);
      }
    }

    return info;
  }

  Logger.warning("No queryset with name ".concat(name, " found"), 'DEVICE.MEDIA');
  return null;
};

var handleChange = function handleChange(name) {
  if (initializedQuerySets[name].timer) {
    clearTimeout(initializedQuerySets[name].timer);
    initializedQuerySets[name].timer = null;
  }

  initializedQuerySets[name].timer = setTimeout(function () {
    var mParams = checkQueries(name, false);

    if (mParams) {
      eventProvider.fireEvent("media_".concat(name), mParams);
    }
  }, supportMatchMediaListener() ? 0 : 100);
}; // public API


var RANGESETS;

(function (RANGESETS) {
  RANGESETS["SAP_3STEPS"] = "3Step";
  RANGESETS["SAP_4STEPS"] = "4Step";
  RANGESETS["SAP_6STEPS"] = "6Step";
  RANGESETS["SAP_STANDARD"] = "Std";
  RANGESETS["SAP_STANDARD_EXTENDED"] = "StdExt";
})(RANGESETS || (RANGESETS = {}));

var DEFAULT_RANGE_SET = RANGESETS.SAP_STANDARD;
var DEFAULT_RANGESETS = (_DEFAULT_RANGESETS = {}, _defineProperty(_DEFAULT_RANGESETS, RANGESETS.SAP_3STEPS, {
  points: [520, 960],
  unit: 'px',
  name: RANGESETS.SAP_3STEPS,
  names: ['S', 'M', 'L']
}), _defineProperty(_DEFAULT_RANGESETS, RANGESETS.SAP_4STEPS, {
  points: [520, 760, 960],
  unit: 'px',
  name: RANGESETS.SAP_4STEPS,
  names: ['S', 'M', 'L', 'XL']
}), _defineProperty(_DEFAULT_RANGESETS, RANGESETS.SAP_6STEPS, {
  points: [241, 400, 541, 768, 960],
  unit: 'px',
  name: RANGESETS.SAP_6STEPS,
  names: ['XS', 'S', 'M', 'L', 'XL', 'XXL']
}), _defineProperty(_DEFAULT_RANGESETS, RANGESETS.SAP_STANDARD, {
  points: [600, 1024],
  unit: 'px',
  name: RANGESETS.SAP_STANDARD,
  names: ['Phone', 'Tablet', 'Desktop']
}), _defineProperty(_DEFAULT_RANGESETS, RANGESETS.SAP_STANDARD_EXTENDED, {
  points: [600, 1024, 1440],
  unit: 'px',
  name: RANGESETS.SAP_STANDARD_EXTENDED,
  names: ['Phone', 'Tablet', 'Desktop', 'LargeDesktop']
}), _DEFAULT_RANGESETS);
var hasRangeSet = function hasRangeSet(sName) {
  return sName && !!initializedQuerySets[sName];
};
var getCurrentRange = function getCurrentRange(rangeSetName, width) {
  if (!initializedQuerySets[DEFAULT_RANGE_SET]) {
    initRangeSet();
  }

  if (!initializedQuerySets[RANGESETS.SAP_STANDARD_EXTENDED]) {
    initRangeSet(RANGESETS.SAP_STANDARD_EXTENDED);
  }

  if (!hasRangeSet(rangeSetName)) {
    return null;
  }

  return checkQueries(rangeSetName, true, isNaN(width) ? null : function (from, to, unit) {
    return matchLegacyBySize(from, to, unit, [width, 0]);
  });
};
var initRangeSet = function initRangeSet(sName, aRangeBorders, sUnit, aRangeNames, bSuppressClasses) {
  var oConfig;

  if (!sName) {
    oConfig = DEFAULT_RANGESETS[DEFAULT_RANGE_SET];
  } else if (sName && DEFAULT_RANGESETS[sName]) {
    oConfig = DEFAULT_RANGESETS[sName];
  } else {
    oConfig = {
      name: sName,
      unit: (sUnit || 'px').toLowerCase(),
      points: aRangeBorders || [],
      names: aRangeNames,
      noClasses: !!bSuppressClasses
    };
  }

  if (hasRangeSet(oConfig.name)) {
    return;
  }

  sName = oConfig.name;
  oConfig.queries = [];
  oConfig.timer = null;
  oConfig.currentquery = null;

  oConfig.listener = function () {
    return handleChange(sName);
  };

  var aPoints = oConfig.points;

  for (var i = 0, len = aPoints.length; i <= len; i++) {
    var from = i === 0 ? 0 : aPoints[i - 1];
    var to = i === aPoints.length ? -1 : aPoints[i];
    var query = getQuery(from, to, oConfig.unit);
    oConfig.queries.push({
      query: query,
      from: from,
      to: to
    });
  }

  if (oConfig.names && oConfig.names.length !== oConfig.queries.length) {
    oConfig.names = null;
  }

  initializedQuerySets[oConfig.name] = oConfig;
  var queries = oConfig.queries;

  var _iterator = _createForOfIteratorHelper(queries),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var q = _step.value;
      q.media = window.matchMedia(q.query);
      q.media.addListener(oConfig.listener);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  oConfig.listener();
};
var removeRangeSet = function removeRangeSet(rangeSetName) {
  if (!hasRangeSet(rangeSetName)) {
    Logger.info("RangeSet ".concat(rangeSetName, " not found, thus could not be removed."), 'DEVICE.MEDIA');
    return;
  }

  for (var x in RANGESETS) {
    if (rangeSetName === RANGESETS[x]) {
      Logger.warning('Cannot remove default rangeset - no action taken.', 'DEVICE.MEDIA');
      return;
    }
  }

  var oConfig = initializedQuerySets[rangeSetName]; // FF, Safari, Chrome, IE10?

  var queries = oConfig.queries;

  var _iterator2 = _createForOfIteratorHelper(queries),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var q = _step2.value;
      q.media.removeListener(oConfig.listener);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  refreshCSSClasses(rangeSetName, '', true); // eslint-disable-next-line no-underscore-dangle

  delete eventProvider._eventRegistry["media_".concat(rangeSetName)];
  delete initializedQuerySets[rangeSetName];
};
var attachMediaHandler = function attachMediaHandler(fnFunction) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RANGE_SET;
  eventProvider.attachEvent("media_".concat(name), fnFunction);
};
var detachMediaHandler = function detachMediaHandler(fnFunction) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_RANGE_SET;
  eventProvider.detachEvent("media_".concat(name), fnFunction);
};

var eventProvider$1 = new EventProvider();
var iResizeTimeout;
var bOrientationChange = false;
var bResize = false;
var iOrientationTimeout;
var iClearFlagTimeout;

var _Utils$getWindowSize = getWindowSize(),
    _Utils$getWindowSize2 = _slicedToArray(_Utils$getWindowSize, 2),
    iWindowWidthOld = _Utils$getWindowSize2[0],
    iWindowHeightOld = _Utils$getWindowSize2[1];

var bKeyboardOpen = false;
var iLastResizeTime;
var rInputTagRegex = /INPUT|TEXTAREA|SELECT/;
var internalWindowSize = {
  height: 0,
  width: 0
};
var internalOrientation = {
  landscape: false,
  portrait: false
}; // PRIVATE API

var setResizeInfo = function setResizeInfo() {
  internalWindowSize.width = getWindowSize()[0];
  internalWindowSize.height = getWindowSize()[1];
};

var setOrientationInfo = function setOrientationInfo() {
  internalOrientation.landscape = isLandscape(true, internalOrientation, bKeyboardOpen);
  internalOrientation.portrait = !internalOrientation.landscape;
};

var clearFlags = function clearFlags() {
  bOrientationChange = false;
  bResize = false;
  iClearFlagTimeout = null;
};

var eventListenersInitialized = false;

var initEventListeners = function initEventListeners() {
  // Add handler for orientationchange and resize after initialization of Device API
  if (supportTouch() && supportOrientation()) {
    // logic for mobile devices which support orientationchange (like ios, android)
    window.addEventListener('resize', handleMobileOrientationResizeChange, false);
    window.addEventListener('orientationchange', handleMobileOrientationResizeChange, false);
  } else {
    // desktop browsers and windows phone/tablet which not support orientationchange
    window.addEventListener('resize', handleResizeEvent, false);
  }

  setResizeInfo();
  setOrientationInfo();
  eventListenersInitialized = true;
}; // orientation change


var handleOrientationChange = function handleOrientationChange() {
  setOrientationInfo();
  eventProvider$1.fireEvent('orientation', {
    landscape: internalOrientation.landscape,
    portrait: internalOrientation.portrait
  });
};

var handleMobileTimeout = function handleMobileTimeout() {
  // with ios split view, the browser fires only resize event and no orientationchange
  // when changing the size of a split view
  // therefore the following if needs to be adapted with additional check of iPad with version greater or equal 9
  // (splitview was introduced with iOS 9)
  if (bResize && (bOrientationChange || getSystem().tablet && getOS().ios && getOS().version >= 9)) {
    handleOrientationChange();
    handleResizeChange();
    bOrientationChange = false;
    bResize = false;

    if (iClearFlagTimeout) {
      window.clearTimeout(iClearFlagTimeout);
      iClearFlagTimeout = null;
    }
  }

  iOrientationTimeout = null;
};

var handleMobileOrientationResizeChange = function handleMobileOrientationResizeChange(evt) {
  if (evt.type === 'resize') {
    if (rInputTagRegex.test(document.activeElement.tagName) && !bOrientationChange) {
      return;
    }

    var _Utils$getWindowSize3 = getWindowSize(),
        _Utils$getWindowSize4 = _slicedToArray(_Utils$getWindowSize3, 2),
        iWindowWidthNew = _Utils$getWindowSize4[0],
        iWindowHeightNew = _Utils$getWindowSize4[1];

    var iTime = new Date().getTime(); // skip multiple resize events by only one orientationchange

    if (iWindowHeightNew === iWindowHeightOld && iWindowWidthNew === iWindowWidthOld) {
      return;
    }

    bResize = true; // on mobile devices opening the keyboard on some devices leads to a resize event
    // in this case only the height changes, not the width

    if (iWindowHeightOld !== iWindowHeightNew && iWindowWidthOld === iWindowWidthNew) {
      // Asus Transformer tablet fires two resize events when orientation changes while keyboard is open.
      // Between these two events, only the height changes. The check of if keyboard is open has to be skipped because
      // it may be judged as keyboard closed but the keyboard is still
      // open which will affect the orientation detection
      if (!iLastResizeTime || iTime - iLastResizeTime > 300) {
        bKeyboardOpen = iWindowHeightNew < iWindowHeightOld;
      }

      handleResizeChange();
    } else {
      iWindowWidthOld = iWindowWidthNew;
    }

    iLastResizeTime = iTime;
    iWindowHeightOld = iWindowHeightNew;

    if (iClearFlagTimeout) {
      window.clearTimeout(iClearFlagTimeout);
      iClearFlagTimeout = null;
    } // Some Android build-in browser fires a resize event after the viewport is applied.
    // This resize event has to be dismissed otherwise when the next orientationchange event happens,
    // a UI5 resize event will be fired with the wrong window size.


    iClearFlagTimeout = window.setTimeout(clearFlags, 1200);
  } else if (evt.type === 'orientationchange') {
    bOrientationChange = true;
  }

  if (iOrientationTimeout) {
    clearTimeout(iOrientationTimeout);
    iOrientationTimeout = null;
  }

  iOrientationTimeout = window.setTimeout(handleMobileTimeout, 50);
}; // RESIZE ONLY WITHOUT ORIENTATION CHANGE


var handleResizeChange = function handleResizeChange() {
  setResizeInfo();
  eventProvider$1.fireEvent('resize', {
    height: internalWindowSize.height,
    width: internalWindowSize.width
  });
};

var handleResizeTimeout = function handleResizeTimeout() {
  handleResizeChange();
  iResizeTimeout = null;
};

var handleResizeEvent = function handleResizeEvent() {
  var wasL = internalOrientation.landscape;
  var isL = isLandscape(false, internalOrientation, bKeyboardOpen);

  if (wasL !== isL) {
    handleOrientationChange();
  } // throttle resize events because most browsers throw one or more resize events per pixel
  // for every resize event inside the period from 150ms (starting from the first resize event),
  // we only fire one resize event after this period


  if (!iResizeTimeout) {
    iResizeTimeout = window.setTimeout(handleResizeTimeout, 150);
  }
}; // re-export everything from the web components device

var getWindowSize$1 = function getWindowSize() {
  return internalWindowSize;
};
var attachResizeHandler = function attachResizeHandler(fnFunction) {
  if (!eventListenersInitialized) {
    initEventListeners();
  }

  eventProvider$1.attachEvent('resize', fnFunction);
};
var detachResizeHandler = function detachResizeHandler(fnFunction) {
  eventProvider$1.detachEvent('resize', fnFunction);
}; // orientation change events

var getOrientation = function getOrientation() {
  return internalOrientation;
};
var attachOrientationChangeHandler = function attachOrientationChangeHandler(fnFunction) {
  if (!eventListenersInitialized) {
    initEventListeners();
  }

  eventProvider$1.attachEvent('orientation', fnFunction);
};
var detachOrientationChangeHandler = function detachOrientationChangeHandler(fnFunction) {
  eventProvider$1.detachEvent('orientation', fnFunction);
};

export { DEFAULT_RANGESETS, DEFAULT_RANGE_SET, RANGESETS, attachMediaHandler, attachOrientationChangeHandler, attachResizeHandler, detachMediaHandler, detachOrientationChangeHandler, detachResizeHandler, getCurrentRange, getOrientation, getWindowSize$1 as getWindowSize, hasRangeSet, initRangeSet, removeRangeSet, supportInputPlaceholder, supportMatchMedia, supportMatchMediaListener, supportOrientation, supportPointerEvents, supportRetina, supportWebSocket };
//# sourceMappingURL=Device.js.map
