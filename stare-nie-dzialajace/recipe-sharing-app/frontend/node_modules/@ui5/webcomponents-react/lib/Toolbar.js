import _extends from '@babel/runtime/helpers/extends';
import _slicedToArray from '@babel/runtime/helpers/slicedToArray';
import { createUseStyles } from 'react-jss';
import { useConsolidatedRef, useI18nBundle } from '@ui5/webcomponents-react-base/lib/hooks';
import { StyleClassHelper } from '@ui5/webcomponents-react-base/lib/StyleClassHelper';
import { usePassThroughHtmlProps } from '@ui5/webcomponents-react-base/lib/usePassThroughHtmlProps';
import { enrichEventWithDetails } from '@ui5/webcomponents-react-base/lib/Utils';
import { SHOW_MORE } from '@ui5/webcomponents-react/dist/assets/i18n/i18n-defaults';
import { ToolbarDesign } from '@ui5/webcomponents-react/lib/ToolbarDesign';
import { ToolbarStyle } from '@ui5/webcomponents-react/lib/ToolbarStyle';
import React, { useRef, useState, useCallback, useEffect, forwardRef, useMemo, cloneElement, useLayoutEffect, createRef } from 'react';
import '@ui5/webcomponents-icons/dist/overflow';
import { ButtonDesign } from '@ui5/webcomponents-react/lib/ButtonDesign';
import { PlacementType } from '@ui5/webcomponents-react/lib/PlacementType';
import { Popover } from '@ui5/webcomponents-react/lib/Popover';
import { ToggleButton } from '@ui5/webcomponents-react/lib/ToggleButton';
import { createPortal } from 'react-dom';
import { ThemingParameters } from '@ui5/webcomponents-react-base/lib/ThemingParameters';
import { CssSizeVariables } from '@ui5/webcomponents-react-base/lib/CssSizeVariables';

var stopPropagation = function stopPropagation(e) {
  e.stopPropagation();
  e.stopImmediatePropagation();
};

var OverflowPopover = function OverflowPopover(props) {
  var lastVisibleIndex = props.lastVisibleIndex,
      contentClass = props.contentClass,
      children = props.children;
  var popoverRef = useRef();

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      pressed = _useState2[0],
      setPressed = _useState2[1];

  var handleToggleButtonClick = useCallback(function (e) {
    if (popoverRef.current) {
      if (!pressed) {
        popoverRef.current.openBy(e.target);
        setPressed(true);
      } else {
        popoverRef.current.close();
      }
    }
  }, [pressed]);
  useEffect(function () {
    return function () {
      if (popoverRef.current) {
        popoverRef.current.close();
      }
    };
  }, []);
  var handleClose = useCallback(function (e) {
    stopPropagation(e);
    setPressed(false);
  }, [setPressed]);
  var renderChildren = useCallback(function () {
    return React.Children.toArray((children === null || children === void 0 ? void 0 : children.type) === React.Fragment ? children.props.children : children).map(function (item, index) {
      if (index > lastVisibleIndex) {
        if (item.type.displayName === 'ToolbarSeparator') {
          return /*#__PURE__*/React.cloneElement(item, {
            style: {
              height: '0.0625rem',
              margin: '0.375rem 0.1875rem',
              width: '100%'
            }
          });
        }

        return item;
      }

      return null;
    });
  }, [children, lastVisibleIndex]);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ToggleButton, {
    design: ButtonDesign.Transparent,
    icon: "overflow",
    onClick: handleToggleButtonClick,
    pressed: pressed
  }), /*#__PURE__*/createPortal( /*#__PURE__*/React.createElement(Popover, {
    placementType: PlacementType.Bottom,
    ref: popoverRef,
    onAfterClose: handleClose
  }, /*#__PURE__*/React.createElement("div", {
    className: contentClass
  }, renderChildren())), document.body));
};

var styles = {
  outerContainer: {
    width: '100%',
    height: CssSizeVariables.sapWcrToolbarHeight,
    position: 'relative',
    overflow: 'hidden',
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderBottom: "solid 0.0625rem ".concat(ThemingParameters.sapGroup_TitleBorderColor)
  },
  hasOverflow: {
    '& $toolbar': {
      maxWidth: 'calc(100% - 44px)'
    }
  },
  clear: {
    borderBottom: 'none'
  },
  active: {
    cursor: 'pointer',
    '&:active': {
      backgroundColor: ThemingParameters.sapActiveColor
    },
    '&:hover': {
      backgroundColor: ThemingParameters.sapList_Hover_Background
    }
  },
  info: {
    // This color is most similar to darken(@sapUiBaseColor, 10)
    backgroundColor: ThemingParameters.sapList_HeaderBorderColor,
    '&$active': {
      backgroundColor: ThemingParameters.sapInfobar_Active_Background,
      '&:active': {
        backgroundColor: "".concat(ThemingParameters.sapInfobar_Active_Background)
      },
      '&:hover': {
        backgroundColor: ThemingParameters.sapInfobar_Hover_Background
      }
    }
  },
  solid: {
    backgroundColor: ThemingParameters.sapBackgroundColor
  },
  transparent: {
    backgroundColor: ThemingParameters.sapToolbar_Background
  },
  toolbar: {
    width: '100%',
    '& >:first-child:not(.spacer)': {
      margin: '0 0.25rem 0 0'
    },
    '& >:last-child:not(.spacer)': {
      margin: '0 0.5rem 0 0.25rem'
    },
    '& > *:not(first-child):not(last-child):not(.spacer)': {
      margin: '0 0.25rem'
    },
    display: 'flex',
    alignItems: 'center',
    maxWidth: '100%'
  },
  overflowButtonContainer: {
    marginRight: '0.5rem'
  },
  popoverContent: {
    maxWidth: '20rem',
    padding: CssSizeVariables.sapWcrToolbarPopoverContentPadding,
    display: 'flex',
    flexDirection: 'column'
  }
};

var useStyles = createUseStyles(styles, {
  name: 'Toolbar'
});

/**
 * Horizontal container most commonly used to display buttons, labels, selects and various other input controls.
 *
 * The content of the `Toolbar` moves into the overflow area from right to left when the available space is not enough in the visible area of the container.
 * It can be accessed by the user through the overflow button that opens it in a popover.
 */
var Toolbar = /*#__PURE__*/forwardRef(function (props, ref) {
  var children = props.children,
      toolbarStyle = props.toolbarStyle,
      design = props.design,
      active = props.active,
      style = props.style,
      tooltip = props.tooltip,
      className = props.className,
      onClick = props.onClick,
      slot = props.slot;
  var classes = useStyles(styles);
  var outerContainer = useConsolidatedRef(ref);
  var controlMetaData = useRef([]);

  var _useState = useState(null),
      _useState2 = _slicedToArray(_useState, 2),
      lastVisibleIndex = _useState2[0],
      setLastVisibleIndex = _useState2[1];

  var passThroughProps = usePassThroughHtmlProps(props, ['onClick']);
  var i18nBundle = useI18nBundle('@ui5/webcomponents-react');
  var toolbarClasses = StyleClassHelper.of(classes.outerContainer);

  if (toolbarStyle === ToolbarStyle.Clear) {
    toolbarClasses.put(classes.clear);
  }

  if (active) {
    toolbarClasses.put(classes.active);
  }

  switch (design) {
    case ToolbarDesign.Solid:
      toolbarClasses.put(classes.solid);
      break;

    case ToolbarDesign.Transparent:
      toolbarClasses.put(classes.transparent);
      break;

    case ToolbarDesign.Info:
      toolbarClasses.put(classes.info);
      break;
  }

  toolbarClasses.putIfPresent(className);
  var childrenWithRef = useMemo(function () {
    controlMetaData.current = [];
    var refactoredChildren = React.Children.toArray(children).map(function (child, index) {
      if (child.type === React.Fragment) {
        return child.props.children.filter(Boolean).map(function (item, itemIndex) {
          return /*#__PURE__*/cloneElement(item, {
            key: ".".concat(index, ":").concat(itemIndex)
          });
        });
      }

      return child;
    });
    return refactoredChildren.flat().map(function (item, index) {
      var _item$type;

      var itemRef = /*#__PURE__*/createRef();
      controlMetaData.current.push({
        ref: itemRef
      }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

      if ((item === null || item === void 0 ? void 0 : (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.displayName) === 'ToolbarSpacer') {
        return item;
      }

      return /*#__PURE__*/React.createElement("div", {
        ref: itemRef,
        key: index
      }, item);
    });
  }, [children, controlMetaData]);
  var overflowNeeded = (lastVisibleIndex || lastVisibleIndex === 0) && React.Children.count(childrenWithRef) !== lastVisibleIndex + 1;
  toolbarClasses.putIfPresent(overflowNeeded && classes.hasOverflow);
  var calculateVisibleItems = useCallback(function () {
    var OVERFLOW_BUTTON_WIDTH = 32 + 8;
    requestAnimationFrame(function () {
      if (!outerContainer.current) return;
      var availableWidth = outerContainer.current.getBoundingClientRect().width;
      var consumedWidth = 0;
      var lastIndex = null;

      if (availableWidth - OVERFLOW_BUTTON_WIDTH <= 0) {
        lastIndex = -1;
      } else {
        controlMetaData.current.forEach(function (item, index) {
          var currentMeta = controlMetaData.current[index];

          if (currentMeta && currentMeta.ref && currentMeta.ref.current) {
            var nextWidth = currentMeta.ref.current.getBoundingClientRect().width;
            nextWidth += index === 0 || index === controlMetaData.current.length - 1 ? 4 : 8; // first & last element = padding: 4px

            if (index === controlMetaData.current.length - 1) {
              if (consumedWidth + nextWidth <= availableWidth - 8) {
                lastIndex = index;
              }
            } else {
              if (consumedWidth + nextWidth <= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index;
              }

              if (consumedWidth < availableWidth - OVERFLOW_BUTTON_WIDTH && consumedWidth + nextWidth >= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index - 1;
              }
            }

            consumedWidth += nextWidth;
          }
        });
      }

      setLastVisibleIndex(lastIndex);
    });
  }, [outerContainer.current, controlMetaData.current, setLastVisibleIndex, childrenWithRef, overflowNeeded]);
  var observer = useRef(new ResizeObserver(calculateVisibleItems));
  useEffect(function () {
    if (outerContainer.current) {
      observer.current.observe(outerContainer.current);
    }

    return function () {
      observer.current.disconnect();
    };
  }, [outerContainer.current]);
  useLayoutEffect(function () {
    calculateVisibleItems();
  }, [calculateVisibleItems]);
  var handleToolbarClick = useCallback(function (e) {
    if (active && typeof onClick === 'function') {
      onClick(enrichEventWithDetails(e));
    }
  }, [onClick, active]);
  return /*#__PURE__*/React.createElement("div", _extends({
    title: tooltip,
    style: style,
    className: toolbarClasses.className,
    ref: outerContainer,
    slot: slot,
    onClick: handleToolbarClick
  }, passThroughProps), /*#__PURE__*/React.createElement("div", {
    className: classes.toolbar
  }, overflowNeeded && React.Children.map(childrenWithRef, function (item, index) {
    if (index >= lastVisibleIndex + 1) {
      return /*#__PURE__*/React.cloneElement(item, {
        style: {
          visibility: 'hidden'
        }
      });
    }

    return item;
  }), !overflowNeeded && childrenWithRef), overflowNeeded && /*#__PURE__*/React.createElement("div", {
    className: classes.overflowButtonContainer,
    title: i18nBundle.getText(SHOW_MORE)
  }, /*#__PURE__*/React.createElement(OverflowPopover, {
    lastVisibleIndex: lastVisibleIndex,
    contentClass: classes.popoverContent
  }, React.Children.toArray(children).map(function (child) {
    if (child.type === React.Fragment) {
      return child.props.children;
    }

    return child;
  }))));
});
Toolbar.defaultProps = {
  toolbarStyle: ToolbarStyle.Standard,
  design: ToolbarDesign.Auto,
  active: false
};
Toolbar.displayName = 'Toolbar';

export { Toolbar };
//# sourceMappingURL=Toolbar.js.map
